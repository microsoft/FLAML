"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9601],{5680:(e,t,n)=>{n.d(t,{xA:()=>m,yg:()=>f});var r=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=c(n),f=o,d=p["".concat(l,".").concat(f)]||p[f]||u[f]||a;return n?r.createElement(d,i(i({ref:t},m),{},{components:n})):r.createElement(d,i({ref:t},m))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},3993:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=n(8168),o=(n(6540),n(5680));const a={},i=void 0,s={unversionedId:"Best-Practices",id:"Best-Practices",isDocsHomePage:!1,title:"Best-Practices",description:"from flaml import AutoML",source:"@site/docs/Best-Practices.md",sourceDirName:".",slug:"/Best-Practices",permalink:"/FLAML/docs/Best-Practices",editUrl:"https://github.com/microsoft/FLAML/edit/main/website/docs/Best-Practices.md",tags:[],version:"current",frontMatter:{}},l=[],c={toc:l};function m(e){let{components:t,...n}=e;return(0,o.yg)("wrapper",(0,r.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-markdown"},'# Best Practices\n\nThis page collects practical guidance for using FLAML effectively across common tasks.\n\n## General tips\n\n- Start simple: set `task`, `time_budget`, and keep `metric="auto"` unless you have a strong reason to override.\n- Prefer correct splits: ensure your evaluation strategy matches your data (time series vs i.i.d., grouped data, etc.).\n- Keep estimator lists explicit when debugging: start with a small `estimator_list` and expand.\n- Use built-in discovery helpers to avoid stale hardcoded lists:\n\n```python\nfrom flaml import AutoML\nfrom flaml.automl.task.factory import task_factory\n\nautoml = AutoML()\nprint("Built-in sklearn metrics:", sorted(automl.supported_metrics[0]))\nprint("classification estimators:", sorted(task_factory("classification").estimators.keys()))\n```\n\n## Classification\n\n- **Metric**: for binary classification, `metric="roc_auc"` is common; for multiclass, `metric="log_loss"` is often robust.\n- **Imbalanced data**:\n  - pass `sample_weight` to `AutoML.fit()`;\n  - consider setting class weights via `custom_hp` / `fit_kwargs_by_estimator` for specific estimators (see [FAQ](FAQ)).\n- **Probability vs label metrics**: use `roc_auc` / `log_loss` when you care about calibrated probabilities.\n\n## Regression\n\n- **Default metric**: `metric="r2"` (minimizes `1 - r2`).\n- If your target scale matters (e.g., dollar error), consider `mae`/`rmse`.\n\n## Learning to rank\n\n- Use `task="rank"` with group information (`groups` / `groups_val`) so metrics like `ndcg` and `ndcg@k` are meaningful.\n- If you pass `metric="ndcg@10"`, also pass `groups` so FLAML can compute group-aware NDCG.\n\n## Time series forecasting\n\n- Use time-aware splitting. For holdout validation, set `eval_method="holdout"` and use a time-ordered dataset.\n- Prefer supplying a DataFrame with a clear time column when possible.\n- Optional time-series estimators depend on optional dependencies. To list what is available in your environment:\n\n```python\nfrom flaml.automl.task.factory import task_factory\n\nprint("forecast:", sorted(task_factory("forecast").estimators.keys()))\n```\n\n## NLP (Transformers)\n\n- Install the optional dependency: `pip install "flaml[hf]"`.\n- When you provide a custom metric, ensure it returns `(metric_to_minimize, metrics_to_log)` with stable keys.\n\n## Speed, stability, and tricky settings\n\n- **Time budget vs convergence**: if you see warnings about not all estimators converging, increase `time_budget` or reduce `estimator_list`.\n- **Memory pressure / OOM**:\n  - set `free_mem_ratio` (e.g., `0.2`) to keep free memory above a threshold;\n  - set `model_history=False` to reduce stored artifacts;\n- **Reproducibility**: set `seed` and keep `n_jobs` fixed; expect some runtime variance.\n\n## Persisting models\n\nFLAML supports **both** MLflow logging and pickle-based persistence. For production deployment, MLflow logging is typically the most important option because it plugs into the MLflow ecosystem (tracking, model registry, serving, governance). For quick local reuse, persisting the whole `AutoML` object via pickle is often the most convenient.\n\n### Option 1: MLflow logging (recommended for production)\n\nWhen you run `AutoML.fit()` inside an MLflow run, FLAML can log metrics/params automatically (disable via `mlflow_logging=False` if needed). To persist the trained `AutoML` object as a model artifact and reuse MLflow tooling end-to-end:\n\n```python\nimport mlflow\nimport numpy as np\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom flaml import AutoML\n\n\nX, y = load_iris(return_X_y=True, as_frame=True)\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n\nautoml = AutoML()\nmlflow.set_experiment("flaml")\nwith mlflow.start_run(run_name="flaml_run") as run:\n    automl.fit(X_train, y_train, task="classification", time_budget=3, retrain_full=False, eval_method="holdout")\n\nrun_id = run.info.run_id\n\n# Later (or in a different process)\nautoml2 = mlflow.sklearn.load_model(f"runs:/{run_id}/model")\nassert np.array_equal(automl2.predict(X_test), automl.predict(X_test))\n```\n\n### Option 2: Pickle the full `AutoML` instance (convenient / Fabric)\n\nPickling stores the *entire* `AutoML` instance (not just the best estimator). This is useful when you prefer not to rely on MLflow or when you want to reuse additional attributes of the AutoML object without retraining.\n\nIn Microsoft Fabric scenarios, this is particularly important for re-plotting visualization figures without requiring model retraining.\n\n```python\nimport mlflow\nimport numpy as np\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom flaml import AutoML\n\n\nX, y = load_iris(return_X_y=True, as_frame=True)\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42\n)\n\nautoml = AutoML()\nmlflow.set_experiment("flaml")\nwith mlflow.start_run(run_name="flaml_run") as run:\n    automl.fit(X_train, y_train, task="classification", time_budget=3, retrain_full=False, eval_method="holdout")\n\nautoml.pickle("automl.pkl")\nautoml2 = AutoML.load_pickle("automl.pkl")\nassert np.array_equal(automl2.predict(X_test), automl.predict(X_test))\nassert automl.best_config == automl2.best_config\nassert automl.best_loss == automl2.best_loss\nassert automl.mlflow_integration.infos == automl2.mlflow_integration.infos\n```\n\nSee also: [Task-Oriented AutoML](Use-Cases/Task-Oriented-AutoML) and [FAQ](FAQ).\n\n')))}m.isMDXComponent=!0}}]);