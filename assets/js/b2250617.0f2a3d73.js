"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3006],{5680:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>g});var a=t(6540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=p(t),g=r,d=m["".concat(l,".").concat(g)]||m[g]||c[g]||i;return t?a.createElement(d,s(s({ref:n},u),{},{components:t})):a.createElement(d,s({ref:n},u))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=m;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=t[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},4807:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=t(8168),r=(t(6540),t(5680));const i={sidebar_label:"suggestion",title:"tune.searcher.suggestion"},s=void 0,o={unversionedId:"reference/tune/searcher/suggestion",id:"reference/tune/searcher/suggestion",isDocsHomePage:!1,title:"tune.searcher.suggestion",description:"Searcher Objects",source:"@site/docs/reference/tune/searcher/suggestion.md",sourceDirName:"reference/tune/searcher",slug:"/reference/tune/searcher/suggestion",permalink:"/FLAML/docs/reference/tune/searcher/suggestion",editUrl:"https://github.com/microsoft/FLAML/edit/main/website/docs/reference/tune/searcher/suggestion.md",tags:[],version:"current",frontMatter:{sidebar_label:"suggestion",title:"tune.searcher.suggestion"},sidebar:"referenceSideBar",previous:{title:"search_thread",permalink:"/FLAML/docs/reference/tune/searcher/search_thread"},next:{title:"variant_generator",permalink:"/FLAML/docs/reference/tune/searcher/variant_generator"}},l=[{value:"Searcher Objects",id:"searcher-objects",children:[{value:"set_search_properties",id:"set_search_properties",children:[],level:4},{value:"on_trial_result",id:"on_trial_result",children:[],level:4},{value:"metric",id:"metric",children:[],level:4},{value:"mode",id:"mode",children:[],level:4}],level:2},{value:"ConcurrencyLimiter Objects",id:"concurrencylimiter-objects",children:[{value:"validate_warmstart",id:"validate_warmstart",children:[],level:4}],level:2},{value:"OptunaSearch Objects",id:"optunasearch-objects",children:[],level:2}],p={toc:l};function u(e){let{components:n,...t}=e;return(0,r.yg)("wrapper",(0,a.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("h2",{id:"searcher-objects"},"Searcher Objects"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"class Searcher()\n")),(0,r.yg)("p",null,"Abstract class for wrapping suggesting algorithms.\nCustom algorithms can extend this class easily by overriding the\n",(0,r.yg)("inlineCode",{parentName:"p"},"suggest")," method provide generated parameters for the trials.\nAny subclass that implements ",(0,r.yg)("inlineCode",{parentName:"p"},"__init__")," must also call the\nconstructor of this class: ",(0,r.yg)("inlineCode",{parentName:"p"},"super(Subclass, self).__init__(...)"),".\nTo track suggestions and their corresponding evaluations, the method\n",(0,r.yg)("inlineCode",{parentName:"p"},"suggest")," will be passed a trial_id, which will be used in\nsubsequent notifications.\nNot all implementations support multi objectives."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"metric")," ",(0,r.yg)("em",{parentName:"li"},"str or list")," - The training result objective value attribute. If\nlist then list of training result objective value attributes"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"mode")," ",(0,r.yg)("em",{parentName:"li"},"str or list")," - If string One of {min, max}. If list then\nlist of max and min, determines whether objective is minimizing\nor maximizing the metric attribute. Must match type of metric.")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'class ExampleSearch(Searcher):\n    def __init__(self, metric="mean_loss", mode="min", **kwargs):\n        super(ExampleSearch, self).__init__(\n            metric=metric, mode=mode, **kwargs)\n        self.optimizer = Optimizer()\n        self.configurations = {}\n    def suggest(self, trial_id):\n        configuration = self.optimizer.query()\n        self.configurations[trial_id] = configuration\n    def on_trial_complete(self, trial_id, result, **kwargs):\n        configuration = self.configurations[trial_id]\n        if result and self.metric in result:\n            self.optimizer.update(configuration, result[self.metric])\ntune.run(trainable_function, search_alg=ExampleSearch())\n')),(0,r.yg)("h4",{id:"set_search_properties"},"set","_","search","_","properties"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"def set_search_properties(metric: Optional[str], mode: Optional[str],\n                          config: Dict) -> bool\n")),(0,r.yg)("p",null,"Pass search properties to searcher.\nThis method acts as an alternative to instantiating search algorithms\nwith their own specific search spaces. Instead they can accept a\nTune config through this method. A searcher should return ",(0,r.yg)("inlineCode",{parentName:"p"},"True"),"\nif setting the config was successful, or ",(0,r.yg)("inlineCode",{parentName:"p"},"False")," if it was\nunsuccessful, e.g. when the search space has already been set."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"metric")," ",(0,r.yg)("em",{parentName:"li"},"str")," - Metric to optimize"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"mode")," ",(0,r.yg)("em",{parentName:"li"},"str")," - One of ",'["min", "max"]',". Direction to optimize."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"config")," ",(0,r.yg)("em",{parentName:"li"},"dict")," - Tune config dict.")),(0,r.yg)("h4",{id:"on_trial_result"},"on","_","trial","_","result"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"def on_trial_result(trial_id: str, result: Dict)\n")),(0,r.yg)("p",null,"Optional notification for result during training.\nNote that by default, the result dict may include NaNs or\nmay not include the optimization metric. It is up to the\nsubclass implementation to preprocess the result to\navoid breaking the optimization process."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"trial_id")," ",(0,r.yg)("em",{parentName:"li"},"str")," - A unique string ID for the trial."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"result")," ",(0,r.yg)("em",{parentName:"li"},"dict")," - Dictionary of metrics for current training progress.\nNote that the result dict may include NaNs or\nmay not include the optimization metric. It is up to the\nsubclass implementation to preprocess the result to\navoid breaking the optimization process.")),(0,r.yg)("h4",{id:"metric"},"metric"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef metric() -> str\n")),(0,r.yg)("p",null,"The training result objective value attribute."),(0,r.yg)("h4",{id:"mode"},"mode"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef mode() -> str\n")),(0,r.yg)("p",null,"Specifies if minimizing or maximizing the metric."),(0,r.yg)("h2",{id:"concurrencylimiter-objects"},"ConcurrencyLimiter Objects"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"class ConcurrencyLimiter(Searcher)\n")),(0,r.yg)("p",null,"A wrapper algorithm for limiting the number of concurrent trials."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"searcher")," ",(0,r.yg)("em",{parentName:"li"},"Searcher")," - Searcher object that the\nConcurrencyLimiter will manage."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"max_concurrent")," ",(0,r.yg)("em",{parentName:"li"},"int")," - Maximum concurrent samples from the underlying\nsearcher."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"batch")," ",(0,r.yg)("em",{parentName:"li"},"bool")," - Whether to wait for all concurrent samples\nto finish before updating the underlying searcher.")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'from ray.tune.suggest import ConcurrencyLimiter  # ray version < 2\nsearch_alg = HyperOptSearch(metric="accuracy")\nsearch_alg = ConcurrencyLimiter(search_alg, max_concurrent=2)\ntune.run(trainable, search_alg=search_alg)\n')),(0,r.yg)("h4",{id:"validate_warmstart"},"validate","_","warmstart"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"def validate_warmstart(parameter_names: List[str],\n                       points_to_evaluate: List[Union[List, Dict]],\n                       evaluated_rewards: List,\n                       validate_point_name_lengths: bool = True)\n")),(0,r.yg)("p",null,"Generic validation of a Searcher's warm start functionality.\nRaises exceptions in case of type and length mismatches between\nparameters.\nIf ",(0,r.yg)("inlineCode",{parentName:"p"},"validate_point_name_lengths")," is False, the equality of lengths\nbetween ",(0,r.yg)("inlineCode",{parentName:"p"},"points_to_evaluate")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"parameter_names")," will not be\nvalidated."),(0,r.yg)("h2",{id:"optunasearch-objects"},"OptunaSearch Objects"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"class OptunaSearch(Searcher)\n")),(0,r.yg)("p",null,"A wrapper around Optuna to provide trial suggestions."),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"Optuna <https://optuna.org/>"),"_ is a hyperparameter optimization library.\nIn contrast to other libraries, it employs define-by-run style\nhyperparameter definitions."),(0,r.yg)("p",null,"This Searcher is a thin wrapper around Optuna's search algorithms.\nYou can pass any Optuna sampler, which will be used to generate\nhyperparameter suggestions."),(0,r.yg)("p",null,"Multi-objective optimization is supported."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"p"},"space")," - Hyperparameter search space definition for\nOptuna's sampler. This can be either a dict with\nparameter names as keys and ",(0,r.yg)("inlineCode",{parentName:"p"},"optuna.distributions")," as values,\nor a Callable - in which case, it should be a define-by-run\nfunction using ",(0,r.yg)("inlineCode",{parentName:"p"},"optuna.trial")," to obtain the hyperparameter\nvalues. The function should return either a dict of\nconstant values with names as keys, or None.\nFor more information, see ",(0,r.yg)("a",{parentName:"p",href:"https://optuna.readthedocs.io/en/stable/tutorial/10_key_features/002_configurations.html"},"https://optuna.readthedocs.io/en/stable/tutorial/10_key_features/002_configurations.html"),"."),(0,r.yg)("p",{parentName:"li"},"Warning - No actual computation should take place in the define-by-run\nfunction. Instead, put the training logic inside the function\nor class trainable passed to ",(0,r.yg)("inlineCode",{parentName:"p"},"tune.run"),".")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"p"},"metric")," - The training result objective value attribute. If\nNone but a mode was passed, the anonymous metric ",(0,r.yg)("inlineCode",{parentName:"p"},"_metric"),"\nwill be used per default. Can be a list of metrics for\nmulti-objective optimization.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"p"},"mode")," - One of {min, max}. Determines whether objective is\nminimizing or maximizing the metric attribute. Can be a list of\nmodes for multi-objective optimization (corresponding to\n",(0,r.yg)("inlineCode",{parentName:"p"},"metric"),").")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"p"},"points_to_evaluate")," - Initial parameter suggestions to be run\nfirst. This is for when you already have some good parameters\nyou want to run first to help the algorithm make better suggestions\nfor future parameters. Needs to be a list of dicts containing the\nconfigurations.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"p"},"sampler")," - Optuna sampler used to\ndraw hyperparameter configurations. Defaults to ",(0,r.yg)("inlineCode",{parentName:"p"},"MOTPESampler"),"\nfor multi-objective optimization with Optuna<2.9.0, and\n",(0,r.yg)("inlineCode",{parentName:"p"},"TPESampler")," in every other case.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"p"},"Warning")," - Please note that with Optuna 2.10.0 and earlier\ndefault ",(0,r.yg)("inlineCode",{parentName:"p"},"MOTPESampler"),"/",(0,r.yg)("inlineCode",{parentName:"p"},"TPESampler")," suffer\nfrom performance issues when dealing with a large number of\ncompleted trials (approx. >100). This will manifest as\na delay when suggesting new configurations.\nThis is an Optuna issue and may be fixed in a future\nOptuna release.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"p"},"seed")," - Seed to initialize sampler with. This parameter is only\nused when ",(0,r.yg)("inlineCode",{parentName:"p"},"sampler=None"),". In all other cases, the sampler\nyou pass should be initialized with the seed already.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("inlineCode",{parentName:"p"},"evaluated_rewards")," - If you have previously evaluated the\nparameters passed in as points_to_evaluate you can avoid\nre-running those trials by passing in the reward attributes\nas a list so the optimiser can be told the results without\nneeding to re-compute the trial. Must be the same length as\npoints_to_evaluate."),(0,r.yg)("p",{parentName:"li"},"Warning - When using ",(0,r.yg)("inlineCode",{parentName:"p"},"evaluated_rewards"),", the search space ",(0,r.yg)("inlineCode",{parentName:"p"},"space"),"\nmust be provided as a dict with parameter names as\nkeys and ",(0,r.yg)("inlineCode",{parentName:"p"},"optuna.distributions")," instances as values. The\ndefine-by-run search space definition is not yet supported with\nthis functionality."),(0,r.yg)("p",{parentName:"li"},"Tune automatically converts search spaces to Optuna's format:"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'from ray.tune.suggest.optuna import OptunaSearch\n\nconfig = {\n    "a": tune.uniform(6, 8)\n    "b": tune.loguniform(1e-4, 1e-2)\n}\n\noptuna_search = OptunaSearch(\n    metric="loss",\n    mode="min")\n\ntune.run(trainable, config=config, search_alg=optuna_search)\n')),(0,r.yg)("p",null,"  If you would like to pass the search space manually, the code would\nlook like this:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'from ray.tune.suggest.optuna import OptunaSearch\nimport optuna\n\nspace = {\n    "a": optuna.distributions.UniformDistribution(6, 8),\n    "b": optuna.distributions.LogUniformDistribution(1e-4, 1e-2),\n}\n\noptuna_search = OptunaSearch(\n    space,\n    metric="loss",\n    mode="min")\n\ntune.run(trainable, search_alg=optuna_search)\n\n# Equivalent Optuna define-by-run function approach:\n\ndef define_search_space(trial: optuna.Trial):\n    trial.suggest_float("a", 6, 8)\n    trial.suggest_float("b", 1e-4, 1e-2, log=True)\n    # training logic goes into trainable, this is just\n    # for search space definition\n\noptuna_search = OptunaSearch(\n    define_search_space,\n    metric="loss",\n    mode="min")\n\ntune.run(trainable, search_alg=optuna_search)\n')),(0,r.yg)("p",null,"  Multi-objective optimization is supported:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'from ray.tune.suggest.optuna import OptunaSearch\nimport optuna\n\nspace = {\n    "a": optuna.distributions.UniformDistribution(6, 8),\n    "b": optuna.distributions.LogUniformDistribution(1e-4, 1e-2),\n}\n\n# Note you have to specify metric and mode here instead of\n# in tune.run\noptuna_search = OptunaSearch(\n    space,\n    metric=["loss1", "loss2"],\n    mode=["min", "max"])\n\n# Do not specify metric and mode here!\ntune.run(\n    trainable,\n    search_alg=optuna_search\n)\n')),(0,r.yg)("p",null,"  You can pass configs that will be evaluated first using\n",(0,r.yg)("inlineCode",{parentName:"p"},"points_to_evaluate"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'from ray.tune.suggest.optuna import OptunaSearch\nimport optuna\n\nspace = {\n    "a": optuna.distributions.UniformDistribution(6, 8),\n    "b": optuna.distributions.LogUniformDistribution(1e-4, 1e-2),\n}\n\noptuna_search = OptunaSearch(\n    space,\n    points_to_evaluate=[{"a": 6.5, "b": 5e-4}, {"a": 7.5, "b": 1e-3}]\n    metric="loss",\n    mode="min")\n\ntune.run(trainable, search_alg=optuna_search)\n')),(0,r.yg)("p",null,"  Avoid re-running evaluated trials by passing the rewards together with\n",(0,r.yg)("inlineCode",{parentName:"p"},"points_to_evaluate"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'from ray.tune.suggest.optuna import OptunaSearch\nimport optuna\n\nspace = {\n    "a": optuna.distributions.UniformDistribution(6, 8),\n    "b": optuna.distributions.LogUniformDistribution(1e-4, 1e-2),\n}\n\noptuna_search = OptunaSearch(\n    space,\n    points_to_evaluate=[{"a": 6.5, "b": 5e-4}, {"a": 7.5, "b": 1e-3}]\n    evaluated_rewards=[0.89, 0.42]\n    metric="loss",\n    mode="min")\n\ntune.run(trainable, search_alg=optuna_search)\n')))}u.isMDXComponent=!0}}]);