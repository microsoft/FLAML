"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7346],{5680:(e,t,a)=>{a.d(t,{xA:()=>p,yg:()=>u});var n=a(6540);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),m=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=m(e.components);return n.createElement(s.Provider,{value:t},e.children)},g={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=m(a),u=i,c=d["".concat(s,".").concat(u)]||d[u]||g[u]||r;return a?n.createElement(c,l(l({ref:t},p),{},{components:a})):n.createElement(c,l({ref:t},p))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var m=2;m<r;m++)l[m]=a[m];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},2321:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var n=a(8168),i=(a(6540),a(5680));const r={sidebar_label:"automl",title:"automl.automl"},l=void 0,o={unversionedId:"reference/automl/automl",id:"reference/automl/automl",isDocsHomePage:!1,title:"automl.automl",description:"size",source:"@site/docs/reference/automl/automl.md",sourceDirName:"reference/automl",slug:"/reference/automl/automl",permalink:"/FLAML/docs/reference/automl/automl",editUrl:"https://github.com/microsoft/FLAML/edit/main/website/docs/reference/automl/automl.md",tags:[],version:"current",frontMatter:{sidebar_label:"automl",title:"automl.automl"},sidebar:"referenceSideBar",previous:{title:"ts_model",permalink:"/FLAML/docs/reference/automl/time_series/ts_model"},next:{title:"data",permalink:"/FLAML/docs/reference/automl/data"}},s=[{value:"size",id:"size",children:[],level:4},{value:"AutoML Objects",id:"automl-objects",children:[{value:"__init__",id:"__init__",children:[],level:4},{value:"config_history",id:"config_history",children:[],level:4},{value:"model",id:"model",children:[],level:4},{value:"best_model_for_estimator",id:"best_model_for_estimator",children:[],level:4},{value:"best_estimator",id:"best_estimator",children:[],level:4},{value:"best_iteration",id:"best_iteration",children:[],level:4},{value:"best_config",id:"best_config",children:[],level:4},{value:"best_config_per_estimator",id:"best_config_per_estimator",children:[],level:4},{value:"best_loss_per_estimator",id:"best_loss_per_estimator",children:[],level:4},{value:"best_loss",id:"best_loss",children:[],level:4},{value:"best_result",id:"best_result",children:[],level:4},{value:"metrics_for_best_config",id:"metrics_for_best_config",children:[],level:4},{value:"best_config_train_time",id:"best_config_train_time",children:[],level:4},{value:"supported_metrics",id:"supported_metrics",children:[],level:4},{value:"feature_transformer",id:"feature_transformer",children:[],level:4},{value:"label_transformer",id:"label_transformer",children:[],level:4},{value:"classes_",id:"classes_",children:[],level:4},{value:"time_to_find_best_model",id:"time_to_find_best_model",children:[],level:4},{value:"predict",id:"predict",children:[],level:4},{value:"predict_proba",id:"predict_proba",children:[],level:4},{value:"add_learner",id:"add_learner",children:[],level:4},{value:"get_estimator_from_log",id:"get_estimator_from_log",children:[],level:4},{value:"retrain_from_log",id:"retrain_from_log",children:[],level:4},{value:"search_space",id:"search_space",children:[],level:4},{value:"low_cost_partial_config",id:"low_cost_partial_config",children:[],level:4},{value:"cat_hp_cost",id:"cat_hp_cost",children:[],level:4},{value:"points_to_evaluate",id:"points_to_evaluate",children:[],level:4},{value:"resource_attr",id:"resource_attr",children:[],level:4},{value:"min_resource",id:"min_resource",children:[],level:4},{value:"max_resource",id:"max_resource",children:[],level:4},{value:"trainable",id:"trainable",children:[],level:4},{value:"metric_constraints",id:"metric_constraints",children:[],level:4},{value:"fit",id:"fit",children:[],level:4}],level:2}],m={toc:s};function p(e){let{components:t,...a}=e;return(0,i.yg)("wrapper",(0,n.A)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("h4",{id:"size"},"size"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"def size(learner_classes: dict, config: dict) -> float\n")),(0,i.yg)("p",null,"Size function."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  The mem size in bytes for a config."),(0,i.yg)("h2",{id:"automl-objects"},"AutoML Objects"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"class AutoML(BaseEstimator)\n")),(0,i.yg)("p",null,"The AutoML class."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Example"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'automl = AutoML()\nautoml_settings = {\n    "time_budget": 60,\n    "metric": \'accuracy\',\n    "task": \'classification\',\n    "log_file_name": \'mylog.log\',\n}\nautoml.fit(X_train = X_train, y_train = y_train, **automl_settings)\n')),(0,i.yg)("h4",{id:"__init__"},"_","_","init","_","_"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"def __init__(**settings)\n")),(0,i.yg)("p",null,"Constructor."),(0,i.yg)("p",null,"Many settings in fit() can be passed to the constructor too.\nIf an argument in fit() is provided, it will override the setting passed to the constructor.\nIf an argument in fit() is not provided but provided in the constructor, the value passed to the constructor will be used."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"metric")," - A string of the metric name or a function,\ne.g., 'accuracy', 'roc_auc', 'roc_auc_ovr', 'roc_auc_ovo', 'roc_auc_weighted',\n'roc_auc_ovo_weighted', 'roc_auc_ovr_weighted', 'f1', 'micro_f1', 'macro_f1',\n'log_loss', 'mae', 'mse', 'r2', 'mape'. Default is 'auto'.\nIf passing a customized metric function, the function needs to\nhave the following input arguments:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"def custom_metric(\n    X_test, y_test, estimator, labels,\n    X_train, y_train, weight_test=None, weight_train=None,\n    config=None, groups_test=None, groups_train=None,\n):\n    return metric_to_minimize, metrics_to_log\n")),(0,i.yg)("p",null,"  which returns a float number as the minimization objective,\nand a dictionary as the metrics to log. E.g.,"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'def custom_metric(\n    X_val, y_val, estimator, labels,\n    X_train, y_train, weight_val=None, weight_train=None,\n    *args,\n):\n    from sklearn.metrics import log_loss\n    import time\n\n    start = time.time()\n    y_pred = estimator.predict_proba(X_val)\n    pred_time = (time.time() - start) / len(X_val)\n    val_loss = log_loss(y_val, y_pred, labels=labels, sample_weight=weight_val)\n    y_pred = estimator.predict_proba(X_train)\n    train_loss = log_loss(y_train, y_pred, labels=labels, sample_weight=weight_train)\n    alpha = 0.5\n    return val_loss * (1 + alpha) - alpha * train_loss, {\n        "val_loss": val_loss,\n        "train_loss": train_loss,\n        "pred_time": pred_time,\n    }\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"task")," - A string of the task type, e.g.,\n'classification', 'regression', 'ts_forecast', 'rank',\n'seq-classification', 'seq-regression', 'summarization',\nor an instance of the Task class."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"n_jobs")," - An integer of the number of threads for training | default=-1.\nUse all available resources when n_jobs == -1."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"log_file_name"),' - A string of the log file name | default="". To disable logging,\nset it to be an empty string "".'),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"estimator_list")," - A list of strings for estimator names, or 'auto'.\ne.g., ",(0,i.yg)("inlineCode",{parentName:"li"},"['lgbm', 'xgboost', 'xgb_limitdepth', 'catboost', 'rf', 'extra_tree']"),"."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"time_budget")," - A float number of the time budget in seconds.\nUse -1 if no time limit."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"max_iter")," - An integer of the maximal number of iterations."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"sample")," - A boolean of whether to sample the training data during\nsearch."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"ensemble")," - boolean or dict | default=False. Whether to perform\nensemble after search. Can be a dict with keys 'passthrough'\nand 'final_estimator' to specify the passthrough and\nfinal_estimator in the stacker. The dict can also contain\n'n_jobs' as the key to specify the number of jobs for the stacker."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"eval_method")," - A string of resampling strategy, one of\n","['auto', 'cv', 'holdout']","."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"split_ratio")," - A float of the valiation data percentage for holdout."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"n_splits")," - An integer of the number of folds for cross - validation."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"log_type")," - A string of the log type, one of\n","['better', 'all']",".\n'better' only logs configs with better loss than previos iters\n'all' logs all the tried configs."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"model_history")," - A boolean of whether to keep the best\nmodel per estimator. Make sure memory is large enough if setting to True. Default False."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"log_training_metric")," - A boolean of whether to log the training\nmetric for each model."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"mem_thres")," - A float of the memory size constraint in bytes."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"pred_time_limit")," - A float of the prediction latency constraint in seconds.\nIt refers to the average prediction time per row in validation data."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"train_time_limit")," - None or a float of the training time constraint in seconds for each trial.\nOnly valid for sequential search."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose")," - int, default=3 | Controls the verbosity, higher means more\nmessages."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose=0")," - logger level = CRITICAL"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose=1")," - logger level = ERROR"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose=2")," - logger level = WARNING"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose=3")," - logger level = INFO"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose=4")," - logger level = DEBUG"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose>5")," - logger level = NOTSET"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"retrain_full")," - bool or str, default=True | whether to retrain the\nselected model on the full training data when using holdout.\nTrue - retrain only after search finishes; False - no retraining;\n'budget' - do best effort to retrain without violating the time\nbudget."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"split_type"),' - str or splitter object, default="auto" | the data split type.',(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"A valid splitter object is an instance of a derived class of scikit-learn\n",(0,i.yg)("a",{parentName:"li",href:"https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html#sklearn.model_selection.KFold"},"KFold"),"\nand have ",(0,i.yg)("inlineCode",{parentName:"li"},"split")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"get_n_splits"),' methods with the same signatures.\nSet eval_method to "cv" to use the splitter object.'),(0,i.yg)("li",{parentName:"ul"},"Valid str options depend on different tasks.\nFor classification tasks, valid choices are\n","[\"auto\", 'stratified', 'uniform', 'time', 'group']",'. "auto" -> stratified.\nFor regression tasks, valid choices are ',"[\"auto\", 'uniform', 'time', 'group']",'.\n"auto" -> uniform.\nFor time series forecast tasks, must be "auto" or \'time\'.\nFor ranking task, must be "auto" or \'group\'.'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"hpo_method")," - str, default=\"auto\" | The hyperparameter\noptimization method. By default, CFO is used for sequential\nsearch and BlendSearch is used for parallel search.\nNo need to set when using flaml's default search space or using\na simple customized search space. When set to 'bs', BlendSearch\nis used. BlendSearch can be tried when the search space is\ncomplex, for example, containing multiple disjoint, discontinuous\nsubspaces. When set to 'random', random search is used."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"starting_points"),' - A dictionary or a str to specify the starting hyperparameter\nconfig for the estimators | default="static".\nIf str:',(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},'if "data", use data-dependent defaults;'),(0,i.yg)("li",{parentName:"ul"},'if "data:path" use data-dependent defaults which are stored at path;'),(0,i.yg)("li",{parentName:"ul"},'if "static", use data-independent defaults.\nIf dict, keys are the name of the estimators, and values are the starting\nhyperparameter configurations for the corresponding estimators.\nThe value can be a single hyperparameter configuration dict or a list\nof hyperparameter configuration dicts.\nIn the following code example, we get starting_points from the\n',(0,i.yg)("inlineCode",{parentName:"li"},"automl")," object and use them in the ",(0,i.yg)("inlineCode",{parentName:"li"},"new_automl")," object.\ne.g.,")))),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"from flaml import AutoML\nautoml = AutoML()\nX_train, y_train = load_iris(return_X_y=True)\nautoml.fit(X_train, y_train)\nstarting_points = automl.best_config_per_estimator\n\nnew_automl = AutoML()\nnew_automl.fit(X_train, y_train, starting_points=starting_points)\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"seed")," - int or None, default=None | The random seed for hpo."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"n_concurrent_trials")," - ","[In preview]"," int, default=1 | The number of\nconcurrent trials. When n_concurrent_trials > 1, flaml performes\n",(0,i.yg)("a",{parentName:"li",href:"/docs/Use-Cases/Task-Oriented-AutoML#parallel-tuning"},"parallel tuning"),"\nand installation of ray or spark is required: ",(0,i.yg)("inlineCode",{parentName:"li"},"pip install flaml[ray]"),"\nor ",(0,i.yg)("inlineCode",{parentName:"li"},"pip install flaml[spark]"),". Please check\n",(0,i.yg)("a",{parentName:"li",href:"https://spark.apache.org/docs/latest/api/python/getting_started/install.html"},"here"),"\nfor more details about installing Spark."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"keep_search_state")," - boolean, default=False | Whether to keep data needed\nfor model search after fit(). By default the state is deleted for\nspace saving."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"preserve_checkpoint")," - boolean, default=True | Whether to preserve the saved checkpoint\non disk when deleting automl. By default the checkpoint is preserved."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"early_stop")," - boolean, default=False | Whether to stop early if the\nsearch is considered to converge."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"force_cancel")," - boolean, default=False | Whether to forcely cancel Spark jobs if the\nsearch time exceeded the time budget."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"mlflow_exp_name")," - str, default=None | The name of the mlflow experiment. This should be specified if\nenable mlflow autologging on Spark. Otherwise it will log all the results into the experiment of the\nsame name as the basename of main entry file."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"append_log")," - boolean, default=False | Whetehr to directly append the log\nrecords to the input log file if it exists."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"auto_augment")," - boolean, default=True | Whether to automatically\naugment rare classes."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"min_sample_size")," - int, default=MIN_SAMPLE_TRAIN | the minimal sample\nsize when sample=True."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"use_ray")," - boolean or dict.\nIf boolean: default=False | Whether to use ray to run the training\nin separate processes. This can be used to prevent OOM for large\ndatasets, but will incur more overhead in time.\nIf dict: the dict contains the keywords arguments to be passed to\n",(0,i.yg)("a",{parentName:"li",href:"https://docs.ray.io/en/latest/tune/api_docs/execution.html"},"ray.tune.run"),"."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"use_spark")," - boolean, default=False | Whether to use spark to run the training\nin parallel spark jobs. This can be used to accelerate training on large models\nand large datasets, but will incur more overhead in time and thus slow down\ntraining in some cases. GPU training is not supported yet when use_spark is True.\nFor Spark clusters, by default, we will launch one trial per executor. However,\nsometimes we want to launch more trials than the number of executors (e.g., local mode).\nIn this case, we can set the environment variable ",(0,i.yg)("inlineCode",{parentName:"li"},"FLAML_MAX_CONCURRENT")," to override\nthe detected ",(0,i.yg)("inlineCode",{parentName:"li"},"num_executors"),". The final number of concurrent trials will be the minimum\nof ",(0,i.yg)("inlineCode",{parentName:"li"},"n_concurrent_trials")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"num_executors"),"."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"free_mem_ratio")," - float between 0 and 1, default=0. The free memory ratio to keep during training."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"metric_constraints"),' - list, default=[] | The list of metric constraints.\nEach element in this list is a 3-tuple, which shall be expressed\nin the following format: the first element of the 3-tuple is the name of the\nmetric, the second element is the inequality sign chosen from ">=" and "<=",\nand the third element is the constraint value. E.g., ',(0,i.yg)("inlineCode",{parentName:"li"},"('val_loss', '<=', 0.1)"),".\nNote that all the metric names in metric_constraints need to be reported via\nthe metrics_to_log dictionary returned by a customized metric function.\nThe customized metric function shall be provided via the ",(0,i.yg)("inlineCode",{parentName:"li"},"metric")," key word\nargument of the fit() function or the automl constructor.\nFind an example in the 4th constraint type in this ",(0,i.yg)("a",{parentName:"li",href:"/docs/Use-Cases/Task-Oriented-AutoML#constraint"},"doc"),".\nIf ",(0,i.yg)("inlineCode",{parentName:"li"},"pred_time_limit")," is provided as one of keyword arguments to fit() function or\nthe automl constructor, flaml will automatically (and under the hood)\nadd it as an additional element in the metric_constraints. Essentially 'pred_time_limit'\nspecifies a constraint about the prediction latency constraint in seconds."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"custom_hp"),' - dict, default=None | The custom search space specified by user.\nIt is a nested dict with keys being the estimator names, and values being dicts\nper estimator search space. In the per estimator search space dict,\nthe keys are the hyperparameter names, and values are dicts of info ("domain",\n"init_value", and "low_cost_init_value") about the search space associated with\nthe hyperparameter (i.e., per hyperparameter search space dict). When custom_hp\nis provided, the built-in search space which is also a nested dict of per estimator\nsearch space dict, will be updated with custom_hp. Note that during this nested dict update,\nthe per hyperparameter search space dicts will be replaced (instead of updated) by the ones\nprovided in custom_hp. Note that the value for "domain" can either be a constant\nor a sample.Domain object.\ne.g.,')),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'custom_hp = {\n     "transformer_ms": {\n         "model_path": {\n             "domain": "albert-base-v2",\n         },\n         "learning_rate": {\n             "domain": tune.choice([1e-4, 1e-5]),\n         }\n     }\n }\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"skip_transform")," - boolean, default=False | Whether to pre-process data prior to modeling."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"fit_kwargs_by_estimator")," - dict, default=None | The user specified keywords arguments, grouped by estimator name.\ne.g.,")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'fit_kwargs_by_estimator = {\n    "transformer": {\n        "output_dir": "test/data/output/",\n        "fp16": False,\n    }\n}\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"mlflow_logging")," - boolean, default=True | Whether to log the training results to mlflow. Not valid if mlflow is not installed.")),(0,i.yg)("h4",{id:"config_history"},"config","_","history"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef config_history() -> dict\n")),(0,i.yg)("p",null,"A dictionary of iter->(estimator, config, time),\nstoring the best estimator, config, and the time when the best\nmodel is updated each time."),(0,i.yg)("h4",{id:"model"},"model"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef model()\n")),(0,i.yg)("p",null,"An object with ",(0,i.yg)("inlineCode",{parentName:"p"},"predict()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"predict_proba()")," method (for\nclassification), storing the best trained model."),(0,i.yg)("h4",{id:"best_model_for_estimator"},"best","_","model","_","for","_","estimator"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"def best_model_for_estimator(estimator_name: str)\n")),(0,i.yg)("p",null,"Return the best model found for a particular estimator."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"estimator_name")," - a str of the estimator's name.")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  An object storing the best model for estimator_name.\nIf ",(0,i.yg)("inlineCode",{parentName:"p"},"model_history")," was set to False during fit(), then the returned model\nis untrained unless estimator_name is the best estimator.\nIf ",(0,i.yg)("inlineCode",{parentName:"p"},"model_history")," was set to True, then the returned model is trained."),(0,i.yg)("h4",{id:"best_estimator"},"best","_","estimator"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef best_estimator()\n")),(0,i.yg)("p",null,"A string indicating the best estimator found."),(0,i.yg)("h4",{id:"best_iteration"},"best","_","iteration"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef best_iteration()\n")),(0,i.yg)("p",null,"An integer of the iteration number where the best\nconfig is found."),(0,i.yg)("h4",{id:"best_config"},"best","_","config"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef best_config()\n")),(0,i.yg)("p",null,"A dictionary of the best configuration."),(0,i.yg)("h4",{id:"best_config_per_estimator"},"best","_","config","_","per","_","estimator"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef best_config_per_estimator()\n")),(0,i.yg)("p",null,"A dictionary of all estimators' best configuration."),(0,i.yg)("h4",{id:"best_loss_per_estimator"},"best","_","loss","_","per","_","estimator"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef best_loss_per_estimator()\n")),(0,i.yg)("p",null,"A dictionary of all estimators' best loss."),(0,i.yg)("h4",{id:"best_loss"},"best","_","loss"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef best_loss()\n")),(0,i.yg)("p",null,"A float of the best loss found."),(0,i.yg)("h4",{id:"best_result"},"best","_","result"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef best_result()\n")),(0,i.yg)("p",null,"Result dictionary for model trained with the best config."),(0,i.yg)("h4",{id:"metrics_for_best_config"},"metrics","_","for","_","best","_","config"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef metrics_for_best_config()\n")),(0,i.yg)("p",null,"Returns a float of the best loss, and a dictionary of the auxiliary metrics to log\nassociated with the best config. These two objects correspond to the returned\nobjects by the customized metric function for the config with the best loss."),(0,i.yg)("h4",{id:"best_config_train_time"},"best","_","config","_","train","_","time"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef best_config_train_time()\n")),(0,i.yg)("p",null,"A float of the seconds taken by training the best config."),(0,i.yg)("h4",{id:"supported_metrics"},"supported","_","metrics"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef supported_metrics()\n")),(0,i.yg)("p",null,"Returns a tuple of supported metrics for the task."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"metrics")," ",(0,i.yg)("em",{parentName:"li"},"Tuple")," - sklearn metrics from sklearn package;\nhuggingface metrics from datasets package;\nspark metrics from pyspark package")),(0,i.yg)("h4",{id:"feature_transformer"},"feature","_","transformer"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef feature_transformer()\n")),(0,i.yg)("p",null,"Returns AutoML Transformer"),(0,i.yg)("h4",{id:"label_transformer"},"label","_","transformer"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef label_transformer()\n")),(0,i.yg)("p",null,"Returns AutoML label transformer"),(0,i.yg)("h4",{id:"classes_"},"classes","_"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef classes_()\n")),(0,i.yg)("p",null,"A numpy array of shape (n_classes,) for class labels."),(0,i.yg)("h4",{id:"time_to_find_best_model"},"time","_","to","_","find","_","best","_","model"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef time_to_find_best_model() -> float\n")),(0,i.yg)("p",null,"Time taken to find best model in seconds."),(0,i.yg)("h4",{id:"predict"},"predict"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"def predict(X: np.array | DataFrame | list[str] | list[list[str]] | psDataFrame, **pred_kwargs, ,)\n")),(0,i.yg)("p",null,"Predict label from features."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"X")," - A numpy array or pandas dataframe or pyspark.pandas dataframe\nof featurized instances, shape n * m,\nor for time series forcast tasks:\na pandas dataframe with the first column containing\ntimestamp values (datetime type) or an integer n for\nthe predict steps (only valid when the estimator is\narima or sarimax). Other columns in the dataframe\nare assumed to be exogenous variables (categorical\nor numeric)."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"**pred_kwargs")," - Other key word arguments to pass to predict() function of\nthe searched learners, such as per_device_eval_batch_size.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"multivariate_X_test = DataFrame({\n    'timeStamp': pd.date_range(start='1/1/2022', end='1/07/2022'),\n    'categorical_col': ['yes', 'yes', 'no', 'no', 'yes', 'no', 'yes'],\n    'continuous_col': [105, 107, 120, 118, 110, 112, 115]\n})\nmodel.predict(multivariate_X_test)\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  A array-like of shape n * 1: each element is a predicted\nlabel for an instance."),(0,i.yg)("h4",{id:"predict_proba"},"predict","_","proba"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"def predict_proba(X, **pred_kwargs)\n")),(0,i.yg)("p",null,"Predict the probability of each class from features, only works for\nclassification problems."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"X")," - A numpy array of featurized instances, shape n * m."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"**pred_kwargs")," - Other key word arguments to pass to predict_proba() function of\nthe searched learners, such as per_device_eval_batch_size.")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  A numpy array of shape n * c. c is the  # classes. Each element at\n(i, j) is the probability for instance i to be in class j."),(0,i.yg)("h4",{id:"add_learner"},"add","_","learner"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"def add_learner(learner_name, learner_class)\n")),(0,i.yg)("p",null,"Add a customized learner."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"learner_name")," - A string of the learner's name."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"learner_class")," - A subclass of flaml.automl.model.BaseEstimator.")),(0,i.yg)("h4",{id:"get_estimator_from_log"},"get","_","estimator","_","from","_","log"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"def get_estimator_from_log(log_file_name: str, record_id: int, task: str | Task)\n")),(0,i.yg)("p",null,"Get the estimator from log file."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"log_file_name")," - A string of the log file name."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"record_id")," - An integer of the record ID in the file,\n0 corresponds to the first trial."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"task")," - A string of the task type,\n'binary', 'multiclass', 'regression', 'ts_forecast', 'rank',\nor an instance of the Task class.")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  An estimator object for the given configuration."),(0,i.yg)("h4",{id:"retrain_from_log"},"retrain","_","from","_","log"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"def retrain_from_log(log_file_name, X_train=None, y_train=None, dataframe=None, label=None, time_budget=np.inf, task: str | Task | None = None, eval_method=None, split_ratio=None, n_splits=None, split_type=None, groups=None, n_jobs=-1, train_best=True, train_full=False, record_id=-1, auto_augment=None, custom_hp=None, skip_transform=None, preserve_checkpoint=True, fit_kwargs_by_estimator=None, **fit_kwargs, ,)\n")),(0,i.yg)("p",null,"Retrain from log file."),(0,i.yg)("p",null,"This function is intended to retrain the logged configurations.\nNOTE: In some rare case, the last config is early stopped to meet time_budget and it's the best config.\nBut the logged config's ITER_HP (e.g., n_estimators) is not reduced."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"log_file_name")," - A string of the log file name."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"X_train")," - A numpy array or dataframe of training data in shape n*m.\nFor time series forecast tasks, the first column of X_train must be the timestamp column (datetime type). Other columns in the dataframe are assumed to be exogenous variables (categorical or numeric)."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"y_train")," - A numpy array or series of labels in shape n*1."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"dataframe")," - A dataframe of training data including label column.\nFor time series forecast tasks, dataframe must be specified and should\nhave at least two columns: timestamp and label, where the first\ncolumn is the timestamp column (datetime type). Other columns\nin the dataframe are assumed to be exogenous variables\n(categorical or numeric)."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"label")," - A str of the label column name, e.g., 'label';"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Note")," - If X_train and y_train are provided,\ndataframe and label are ignored;\nIf not, dataframe and label must be provided."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"time_budget")," - A float number of the time budget in seconds."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"task")," - A string of the task type, e.g.,\n'classification', 'regression', 'ts_forecast', 'rank',\n'seq-classification', 'seq-regression', 'summarization',\nor an instance of Task class."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"eval_method")," - A string of resampling strategy, one of\n","['auto', 'cv', 'holdout']","."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"split_ratio")," - A float of the validation data percentage for holdout."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"n_splits")," - An integer of the number of folds for cross-validation."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"split_type"),' - str or splitter object, default="auto" | the data split type.',(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"A valid splitter object is an instance of a derived class of scikit-learn\n",(0,i.yg)("a",{parentName:"li",href:"https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html#sklearn.model_selection.KFold"},"KFold"),"\nand have ",(0,i.yg)("inlineCode",{parentName:"li"},"split")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"get_n_splits"),' methods with the same signatures.\nSet eval_method to "cv" to use the splitter object.'),(0,i.yg)("li",{parentName:"ul"},"Valid str options depend on different tasks.\nFor classification tasks, valid choices are\n","[\"auto\", 'stratified', 'uniform', 'time', 'group']",'. "auto" -> stratified.\nFor regression tasks, valid choices are ',"[\"auto\", 'uniform', 'time', 'group']",'.\n"auto" -> uniform.\nFor time series forecast tasks, must be "auto" or \'time\'.\nFor ranking task, must be "auto" or \'group\'.'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"groups")," - None or array-like | Group labels (with matching length to\ny_train) or groups counts (with sum equal to length of y_train)\nfor training data."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"n_jobs")," - An integer of the number of threads for training | default=-1.\nUse all available resources when n_jobs == -1."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"train_best")," - A boolean of whether to train the best config in the\ntime budget; if false, train the last config in the budget."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"train_full")," - A boolean of whether to train on the full data. If true,\neval_method and sample_size in the log file will be ignored."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"record_id")," - the ID of the training log record from which the model will\nbe retrained. By default ",(0,i.yg)("inlineCode",{parentName:"li"},"record_id = -1")," which means this will be\nignored. ",(0,i.yg)("inlineCode",{parentName:"li"},"record_id = 0")," corresponds to the first trial, and\nwhen ",(0,i.yg)("inlineCode",{parentName:"li"},"record_id >= 0"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"time_budget")," will be ignored."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"auto_augment")," - boolean, default=True | Whether to automatically\naugment rare classes."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"custom_hp")," - dict, default=None | The custom search space specified by user\nEach key is the estimator name, each value is a dict of the custom search space for that estimator. Notice the\ndomain of the custom search space can either be a value or a sample.Domain object.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'custom_hp = {\n    "transformer_ms": {\n        "model_path": {\n            "domain": "albert-base-v2",\n        },\n        "learning_rate": {\n            "domain": tune.choice([1e-4, 1e-5]),\n        }\n    }\n}\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"fit_kwargs_by_estimator")," - dict, default=None | The user specified keywords arguments, grouped by estimator name.\ne.g.,")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'fit_kwargs_by_estimator = {\n    "transformer": {\n        "output_dir": "test/data/output/",\n        "fp16": False,\n    }\n}\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"**fit_kwargs")," - Other key word arguments to pass to fit() function of\nthe searched learners, such as sample_weight. Below are a few examples of\nestimator-specific parameters:"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"period")," - int | forecast horizon for all time series forecast tasks."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"gpu_per_trial")," - float, default = 0 | A float of the number of gpus per trial,\nonly used by TransformersEstimator, XGBoostSklearnEstimator, and\nTemporalFusionTransformerEstimator."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"group_ids")," - list of strings of column names identifying a time series, only\nused by TemporalFusionTransformerEstimator, required for\n'ts_forecast_panel' task. ",(0,i.yg)("inlineCode",{parentName:"li"},"group_ids")," is a parameter for TimeSeriesDataSet object\nfrom PyTorchForecasting.\nFor other parameters to describe your dataset, refer to\n",(0,i.yg)("a",{parentName:"li",href:"https://pytorch-forecasting.readthedocs.io/en/stable/api/pytorch_forecasting.data.timeseries.TimeSeriesDataSet.html"},"TimeSeriesDataSet PyTorchForecasting"),".\nTo specify your variables, use ",(0,i.yg)("inlineCode",{parentName:"li"},"static_categoricals"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"static_reals"),",\n",(0,i.yg)("inlineCode",{parentName:"li"},"time_varying_known_categoricals"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"time_varying_known_reals"),",\n",(0,i.yg)("inlineCode",{parentName:"li"},"time_varying_unknown_categoricals"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"time_varying_unknown_reals"),",\n",(0,i.yg)("inlineCode",{parentName:"li"},"variable_groups"),". To provide more information on your data, use\n",(0,i.yg)("inlineCode",{parentName:"li"},"max_encoder_length"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"min_encoder_length"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"lags"),"."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"log_dir"),' - str, default = "lightning_logs" | Folder into which to log results\nfor tensorboard, only used by TemporalFusionTransformerEstimator.'),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"max_epochs")," - int, default = 20 | Maximum number of epochs to run training,\nonly used by TemporalFusionTransformerEstimator."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"batch_size")," - int, default = 64 | Batch size for training model, only\nused by TemporalFusionTransformerEstimator and TCNEstimator.")),(0,i.yg)("h4",{id:"search_space"},"search","_","space"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef search_space() -> dict\n")),(0,i.yg)("p",null,"Search space."),(0,i.yg)("p",null,"Must be called after fit(...)\n(use max_iter=0 and retrain_final=False to prevent actual fitting)."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  A dict of the search space."),(0,i.yg)("h4",{id:"low_cost_partial_config"},"low","_","cost","_","partial","_","config"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef low_cost_partial_config() -> dict\n")),(0,i.yg)("p",null,"Low cost partial config."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  A dict.\n(a) if there is only one estimator in estimator_list, each key is a\nhyperparameter name.\n(b) otherwise, it is a nested dict with 'ml' as the key, and\na list of the low_cost_partial_configs as the value, corresponding\nto each learner's low_cost_partial_config; the estimator index as\nan integer corresponding to the cheapest learner is appended to the\nlist at the end."),(0,i.yg)("h4",{id:"cat_hp_cost"},"cat","_","hp","_","cost"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef cat_hp_cost() -> dict\n")),(0,i.yg)("p",null,"Categorical hyperparameter cost"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  A dict.\n(a) if there is only one estimator in estimator_list, each key is a\nhyperparameter name.\n(b) otherwise, it is a nested dict with 'ml' as the key, and\na list of the cat_hp_cost's as the value, corresponding\nto each learner's cat_hp_cost; the cost relative to lgbm for each\nlearner (as a list itself) is appended to the list at the end."),(0,i.yg)("h4",{id:"points_to_evaluate"},"points","_","to","_","evaluate"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef points_to_evaluate() -> dict\n")),(0,i.yg)("p",null,"Initial points to evaluate."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  A list of dicts. Each dict is the initial point for each learner."),(0,i.yg)("h4",{id:"resource_attr"},"resource","_","attr"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef resource_attr() -> str | None\n")),(0,i.yg)("p",null,"Attribute of the resource dimension."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  A string for the sample size attribute\n(the resource attribute in AutoML) or None."),(0,i.yg)("h4",{id:"min_resource"},"min","_","resource"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef min_resource() -> float | None\n")),(0,i.yg)("p",null,"Attribute for pruning."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  A float for the minimal sample size or None."),(0,i.yg)("h4",{id:"max_resource"},"max","_","resource"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef max_resource() -> float | None\n")),(0,i.yg)("p",null,"Attribute for pruning."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  A float for the maximal sample size or None."),(0,i.yg)("h4",{id:"trainable"},"trainable"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef trainable() -> Callable[[dict], float | None]\n")),(0,i.yg)("p",null,"Training function."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  A function that evaluates each config and returns the loss."),(0,i.yg)("h4",{id:"metric_constraints"},"metric","_","constraints"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef metric_constraints() -> list\n")),(0,i.yg)("p",null,"Metric constraints."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Returns"),":"),(0,i.yg)("p",null,"  A list of the metric constraints."),(0,i.yg)("h4",{id:"fit"},"fit"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"def fit(X_train=None, y_train=None, dataframe=None, label=None, metric=None, task: str | Task | None = None, n_jobs=None, log_file_name=None, estimator_list=None, time_budget=None, max_iter=None, sample=None, ensemble=None, eval_method=None, log_type=None, model_history=None, split_ratio=None, n_splits=None, log_training_metric=None, mem_thres=None, pred_time_limit=None, train_time_limit=None, X_val=None, y_val=None, sample_weight_val=None, groups_val=None, groups=None, verbose=None, retrain_full=None, split_type=None, learner_selector=None, hpo_method=None, starting_points=None, seed=None, n_concurrent_trials=None, keep_search_state=None, preserve_checkpoint=True, early_stop=None, force_cancel=None, append_log=None, auto_augment=None, min_sample_size=None, use_ray=None, use_spark=None, free_mem_ratio=0, metric_constraints=None, custom_hp=None, time_col=None, cv_score_agg_func=None, skip_transform=None, mlflow_logging=None, fit_kwargs_by_estimator=None, mlflow_exp_name=None, **fit_kwargs, ,)\n")),(0,i.yg)("p",null,"Find a model for a given task."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"X_train")," - A numpy array or a pandas dataframe of training data in\nshape (n, m). For time series forecsat tasks, the first column of X_train\nmust be the timestamp column (datetime type). Other columns in\nthe dataframe are assumed to be exogenous variables (categorical or numeric).\nWhen using ray, X_train can be a ray.ObjectRef."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"y_train")," - A numpy array or a pandas series of labels in shape (n, )."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"dataframe")," - A dataframe of training data including label column.\nFor time series forecast tasks, dataframe must be specified and must have\nat least two columns, timestamp and label, where the first\ncolumn is the timestamp column (datetime type). Other columns in\nthe dataframe are assumed to be exogenous variables (categorical or numeric).\nWhen using ray, dataframe can be a ray.ObjectRef."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"label")," - A str of the label column name for, e.g., 'label';"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Note")," - If X_train and y_train are provided,\ndataframe and label are ignored;\nIf not, dataframe and label must be provided."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"metric")," - A string of the metric name or a function,\ne.g., 'accuracy', 'roc_auc', 'roc_auc_ovr', 'roc_auc_ovo', 'roc_auc_weighted',\n'roc_auc_ovo_weighted', 'roc_auc_ovr_weighted', 'f1', 'micro_f1', 'macro_f1',\n'log_loss', 'mae', 'mse', 'r2', 'mape'. Default is 'auto'.\nIf passing a customized metric function, the function needs to\nhave the following input arguments:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"def custom_metric(\n    X_test, y_test, estimator, labels,\n    X_train, y_train, weight_test=None, weight_train=None,\n    config=None, groups_test=None, groups_train=None,\n):\n    return metric_to_minimize, metrics_to_log\n")),(0,i.yg)("p",null,"  which returns a float number as the minimization objective,\nand a dictionary as the metrics to log. E.g.,"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'def custom_metric(\n    X_val, y_val, estimator, labels,\n    X_train, y_train, weight_val=None, weight_train=None,\n    *args,\n):\n    from sklearn.metrics import log_loss\n    import time\n\n    start = time.time()\n    y_pred = estimator.predict_proba(X_val)\n    pred_time = (time.time() - start) / len(X_val)\n    val_loss = log_loss(y_val, y_pred, labels=labels, sample_weight=weight_val)\n    y_pred = estimator.predict_proba(X_train)\n    train_loss = log_loss(y_train, y_pred, labels=labels, sample_weight=weight_train)\n    alpha = 0.5\n    return val_loss * (1 + alpha) - alpha * train_loss, {\n        "val_loss": val_loss,\n        "train_loss": train_loss,\n        "pred_time": pred_time,\n    }\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"task")," - A string of the task type, e.g.,\n'classification', 'regression', 'ts_forecast_regression',\n'ts_forecast_classification', 'rank', 'seq-classification',\n'seq-regression', 'summarization', or an instance of Task class"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"n_jobs")," - An integer of the number of threads for training | default=-1.\nUse all available resources when n_jobs == -1."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"log_file_name"),' - A string of the log file name | default="". To disable logging,\nset it to be an empty string "".'),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"estimator_list")," - A list of strings for estimator names, or 'auto'.\ne.g., ",(0,i.yg)("inlineCode",{parentName:"li"},"['lgbm', 'xgboost', 'xgb_limitdepth', 'catboost', 'rf', 'extra_tree']"),"."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"time_budget")," - A float number of the time budget in seconds.\nUse -1 if no time limit."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"max_iter")," - An integer of the maximal number of iterations."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"NOTE")," - when both time_budget and max_iter are unspecified,\nonly one model will be trained per estimator."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"sample")," - A boolean of whether to sample the training data during\nsearch."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"ensemble")," - boolean or dict | default=False. Whether to perform\nensemble after search. Can be a dict with keys 'passthrough'\nand 'final_estimator' to specify the passthrough and\nfinal_estimator in the stacker. The dict can also contain\n'n_jobs' as the key to specify the number of jobs for the stacker."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"eval_method")," - A string of resampling strategy, one of\n","['auto', 'cv', 'holdout']","."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"split_ratio")," - A float of the valiation data percentage for holdout."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"n_splits")," - An integer of the number of folds for cross - validation."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"log_type")," - A string of the log type, one of\n","['better', 'all']",".\n'better' only logs configs with better loss than previos iters\n'all' logs all the tried configs."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"model_history")," - A boolean of whether to keep the trained best\nmodel per estimator. Make sure memory is large enough if setting to True.\nDefault value is False. If False, best_model_for_estimator would return a\nuntrained model for non-best learner."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"log_training_metric")," - A boolean of whether to log the training\nmetric for each model."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"mem_thres")," - A float of the memory size constraint in bytes."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"pred_time_limit")," - A float of the prediction latency constraint in seconds.\nIt refers to the average prediction time per row in validation data."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"train_time_limit")," - None or a float of the training time constraint in seconds for each trial.\nOnly valid for sequential search."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"X_val")," - None or a numpy array or a pandas dataframe of validation data."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"y_val")," - None or a numpy array or a pandas series of validation labels."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"sample_weight_val")," - None or a numpy array of the sample weight of\nvalidation data of the same shape as y_val."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"groups_val")," - None or array-like | group labels (with matching length\nto y_val) or group counts (with sum equal to length of y_val)\nfor validation data. Need to be consistent with groups."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"groups")," - None or array-like | Group labels (with matching length to\ny_train) or groups counts (with sum equal to length of y_train)\nfor training data."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose")," - int, default=3 | Controls the verbosity, higher means more\nmessages."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose=0")," - logger level = CRITICAL"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose=1")," - logger level = ERROR"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose=2")," - logger level = WARNING"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose=3")," - logger level = INFO"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose=4")," - logger level = DEBUG"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"verbose>5")," - logger level = NOTSET"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"retrain_full")," - bool or str, default=True | whether to retrain the\nselected model on the full training data when using holdout.\nTrue - retrain only after search finishes; False - no retraining;\n'budget' - do best effort to retrain without violating the time\nbudget."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"split_type"),' - str or splitter object, default="auto" | the data split type.',(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"A valid splitter object is an instance of a derived class of scikit-learn\n",(0,i.yg)("a",{parentName:"li",href:"https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html#sklearn.model_selection.KFold"},"KFold"),"\nand have ",(0,i.yg)("inlineCode",{parentName:"li"},"split")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"get_n_splits"),' methods with the same signatures.\nSet eval_method to "cv" to use the splitter object.'),(0,i.yg)("li",{parentName:"ul"},"Valid str options depend on different tasks.\nFor classification tasks, valid choices are\n","[\"auto\", 'stratified', 'uniform', 'time', 'group']",'. "auto" -> stratified.\nFor regression tasks, valid choices are ',"[\"auto\", 'uniform', 'time', 'group']",'.\n"auto" -> uniform.\nFor time series forecast tasks, must be "auto" or \'time\'.\nFor ranking task, must be "auto" or \'group\'.'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"hpo_method")," - str, default=\"auto\" | The hyperparameter\noptimization method. By default, CFO is used for sequential\nsearch and BlendSearch is used for parallel search.\nNo need to set when using flaml's default search space or using\na simple customized search space. When set to 'bs', BlendSearch\nis used. BlendSearch can be tried when the search space is\ncomplex, for example, containing multiple disjoint, discontinuous\nsubspaces. When set to 'random', random search is used."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"starting_points"),' - A dictionary or a str to specify the starting hyperparameter\nconfig for the estimators | default="data".\nIf str:',(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},'if "data", use data-dependent defaults;'),(0,i.yg)("li",{parentName:"ul"},'if "data:path" use data-dependent defaults which are stored at path;'),(0,i.yg)("li",{parentName:"ul"},'if "static", use data-independent defaults.\nIf dict, keys are the name of the estimators, and values are the starting\nhyperparameter configurations for the corresponding estimators.\nThe value can be a single hyperparameter configuration dict or a list\nof hyperparameter configuration dicts.\nIn the following code example, we get starting_points from the\n',(0,i.yg)("inlineCode",{parentName:"li"},"automl")," object and use them in the ",(0,i.yg)("inlineCode",{parentName:"li"},"new_automl")," object.\ne.g.,")))),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"from flaml import AutoML\nautoml = AutoML()\nX_train, y_train = load_iris(return_X_y=True)\nautoml.fit(X_train, y_train)\nstarting_points = automl.best_config_per_estimator\n\nnew_automl = AutoML()\nnew_automl.fit(X_train, y_train, starting_points=starting_points)\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"seed")," - int or None, default=None | The random seed for hpo."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"n_concurrent_trials")," - ","[In preview]"," int, default=1 | The number of\nconcurrent trials. When n_concurrent_trials > 1, flaml performes\n",(0,i.yg)("a",{parentName:"li",href:"/docs/Use-Cases/Task-Oriented-AutoML#parallel-tuning"},"parallel tuning"),"\nand installation of ray or spark is required: ",(0,i.yg)("inlineCode",{parentName:"li"},"pip install flaml[ray]"),"\nor ",(0,i.yg)("inlineCode",{parentName:"li"},"pip install flaml[spark]"),". Please check\n",(0,i.yg)("a",{parentName:"li",href:"https://spark.apache.org/docs/latest/api/python/getting_started/install.html"},"here"),"\nfor more details about installing Spark."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"keep_search_state")," - boolean, default=False | Whether to keep data needed\nfor model search after fit(). By default the state is deleted for\nspace saving."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"preserve_checkpoint")," - boolean, default=True | Whether to preserve the saved checkpoint\non disk when deleting automl. By default the checkpoint is preserved."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"early_stop")," - boolean, default=False | Whether to stop early if the\nsearch is considered to converge."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"force_cancel")," - boolean, default=False | Whether to forcely cancel the PySpark job if overtime."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"mlflow_exp_name")," - str, default=None | The name of the mlflow experiment. This should be specified if\nenable mlflow autologging on Spark. Otherwise it will log all the results into the experiment of the\nsame name as the basename of main entry file."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"append_log")," - boolean, default=False | Whetehr to directly append the log\nrecords to the input log file if it exists."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"auto_augment")," - boolean, default=True | Whether to automatically\naugment rare classes."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"min_sample_size")," - int, default=MIN_SAMPLE_TRAIN | the minimal sample\nsize when sample=True."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"use_ray")," - boolean or dict.\nIf boolean: default=False | Whether to use ray to run the training\nin separate processes. This can be used to prevent OOM for large\ndatasets, but will incur more overhead in time.\nIf dict: the dict contains the keywords arguments to be passed to\n",(0,i.yg)("a",{parentName:"li",href:"https://docs.ray.io/en/latest/tune/api_docs/execution.html"},"ray.tune.run"),"."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"use_spark")," - boolean, default=False | Whether to use spark to run the training\nin parallel spark jobs. This can be used to accelerate training on large models\nand large datasets, but will incur more overhead in time and thus slow down\ntraining in some cases."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"free_mem_ratio")," - float between 0 and 1, default=0. The free memory ratio to keep during training."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"metric_constraints"),' - list, default=[] | The list of metric constraints.\nEach element in this list is a 3-tuple, which shall be expressed\nin the following format: the first element of the 3-tuple is the name of the\nmetric, the second element is the inequality sign chosen from ">=" and "<=",\nand the third element is the constraint value. E.g., ',(0,i.yg)("inlineCode",{parentName:"li"},"('precision', '>=', 0.9)"),".\nNote that all the metric names in metric_constraints need to be reported via\nthe metrics_to_log dictionary returned by a customized metric function.\nThe customized metric function shall be provided via the ",(0,i.yg)("inlineCode",{parentName:"li"},"metric")," key word argument\nof the fit() function or the automl constructor.\nFind examples in this ",(0,i.yg)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/tree/main/test/automl/test_constraints.py"},"test"),".\nIf ",(0,i.yg)("inlineCode",{parentName:"li"},"pred_time_limit")," is provided as one of keyword arguments to fit() function or\nthe automl constructor, flaml will automatically (and under the hood)\nadd it as an additional element in the metric_constraints. Essentially 'pred_time_limit'\nspecifies a constraint about the prediction latency constraint in seconds."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"custom_hp")," - dict, default=None | The custom search space specified by user\nEach key is the estimator name, each value is a dict of the custom search space for that estimator. Notice the\ndomain of the custom search space can either be a value of a sample.Domain object.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'custom_hp = {\n    "transformer_ms": {\n        "model_path": {\n            "domain": "albert-base-v2",\n        },\n        "learning_rate": {\n            "domain": tune.choice([1e-4, 1e-5]),\n        }\n    }\n}\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"time_col")," - for a time series task, name of the column containing the timestamps. If not\nprovided, defaults to the first column of X_train/X_val")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"cv_score_agg_func")," - customized cross-validation scores aggregate function. Default to average metrics across folds. If specificed, this function needs to\nhave the following input arguments:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"val_loss_folds: list of floats, the loss scores of each fold;"),(0,i.yg)("li",{parentName:"ul"},"log_metrics_folds: list of dicts/floats, the metrics of each fold to log.")),(0,i.yg)("p",{parentName:"li"},"This function should return the final aggregate result of all folds. A float number of the minimization objective, and a dictionary as the metrics to log or None.\nE.g.,"))),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"def cv_score_agg_func(val_loss_folds, log_metrics_folds):\n    metric_to_minimize = sum(val_loss_folds)/len(val_loss_folds)\n    metrics_to_log = None\n    for single_fold in log_metrics_folds:\n        if metrics_to_log is None:\n            metrics_to_log = single_fold\n        elif isinstance(metrics_to_log, dict):\n            metrics_to_log = {k: metrics_to_log[k] + v for k, v in single_fold.items()}\n        else:\n            metrics_to_log += single_fold\n    if metrics_to_log:\n        n = len(val_loss_folds)\n        metrics_to_log = (\n            {k: v / n for k, v in metrics_to_log.items()}\n            if isinstance(metrics_to_log, dict)\n            else metrics_to_log / n\n        )\n    return metric_to_minimize, metrics_to_log\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"skip_transform")," - boolean, default=False | Whether to pre-process data prior to modeling."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"mlflow_logging")," - boolean, default=None | Whether to log the training results to mlflow.\nDefault value is None, which means the logging decision is made based on\nAutoML.",(0,i.yg)("strong",{parentName:"li"},"init"),"'s mlflow_logging argument. Not valid if mlflow is not installed."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"fit_kwargs_by_estimator")," - dict, default=None | The user specified keywords arguments, grouped by estimator name.\nFor TransformersEstimator, available fit_kwargs can be found from\n",(0,i.yg)("a",{parentName:"li",href:"nlp/huggingface/training_args"},"TrainingArgumentsForAuto"),".\ne.g.,")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'fit_kwargs_by_estimator = {\n    "transformer": {\n        "output_dir": "test/data/output/",\n        "fp16": False,\n    },\n    "tft": {\n        "max_encoder_length": 1,\n        "min_encoder_length": 1,\n        "static_categoricals": [],\n        "static_reals": [],\n        "time_varying_known_categoricals": [],\n        "time_varying_known_reals": [],\n        "time_varying_unknown_categoricals": [],\n        "time_varying_unknown_reals": [],\n        "variable_groups": {},\n        "lags": {},\n    }\n}\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"**fit_kwargs")," - Other key word arguments to pass to fit() function of\nthe searched learners, such as sample_weight. Below are a few examples of\nestimator-specific parameters:"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"period")," - int | forecast horizon for all time series forecast tasks."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"gpu_per_trial")," - float, default = 0 | A float of the number of gpus per trial,\nonly used by TransformersEstimator, XGBoostSklearnEstimator, and\nTemporalFusionTransformerEstimator."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"group_ids")," - list of strings of column names identifying a time series, only\nused by TemporalFusionTransformerEstimator, required for\n'ts_forecast_panel' task. ",(0,i.yg)("inlineCode",{parentName:"li"},"group_ids")," is a parameter for TimeSeriesDataSet object\nfrom PyTorchForecasting.\nFor other parameters to describe your dataset, refer to\n",(0,i.yg)("a",{parentName:"li",href:"https://pytorch-forecasting.readthedocs.io/en/stable/api/pytorch_forecasting.data.timeseries.TimeSeriesDataSet.html"},"TimeSeriesDataSet PyTorchForecasting"),".\nTo specify your variables, use ",(0,i.yg)("inlineCode",{parentName:"li"},"static_categoricals"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"static_reals"),",\n",(0,i.yg)("inlineCode",{parentName:"li"},"time_varying_known_categoricals"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"time_varying_known_reals"),",\n",(0,i.yg)("inlineCode",{parentName:"li"},"time_varying_unknown_categoricals"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"time_varying_unknown_reals"),",\n",(0,i.yg)("inlineCode",{parentName:"li"},"variable_groups"),". To provide more information on your data, use\n",(0,i.yg)("inlineCode",{parentName:"li"},"max_encoder_length"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"min_encoder_length"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"lags"),"."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"log_dir"),' - str, default = "lightning_logs" | Folder into which to log results\nfor tensorboard, only used by TemporalFusionTransformerEstimator.'),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"max_epochs")," - int, default = 20 | Maximum number of epochs to run training,\nonly used by TemporalFusionTransformerEstimator."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"batch_size")," - int, default = 64 | Batch size for training model, only\nused by TemporalFusionTransformerEstimator and TCNEstimator.")))}p.isMDXComponent=!0}}]);