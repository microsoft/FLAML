"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5063],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),h=i,d=m["".concat(l,".").concat(h)]||m[h]||u[h]||o;return n?a.createElement(d,r(r({ref:t},c),{},{components:n})):a.createElement(d,r({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7194:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const o={},r="AutoGen: Enabling Next-Gen GPT-X Applications",s={unversionedId:"Use-Cases/Autogen",id:"Use-Cases/Autogen",isDocsHomePage:!1,title:"AutoGen: Enabling Next-Gen GPT-X Applications",description:"flaml.autogen simplifies the orchestration, automation and optimization of a complex GPT-X workflow. It maximizes the performance of GPT-X models and augments their weakness. It enables building next-gen GPT-X applications based on multi-agent conversations with minimal effort.",source:"@site/docs/Use-Cases/Autogen.md",sourceDirName:"Use-Cases",slug:"/Use-Cases/Autogen",permalink:"/FLAML/docs/Use-Cases/Autogen",editUrl:"https://github.com/microsoft/FLAML/edit/main/website/docs/Use-Cases/Autogen.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Installation",permalink:"/FLAML/docs/Installation"},next:{title:"Task Oriented AutoML",permalink:"/FLAML/docs/Use-Cases/Task-Oriented-AutoML"}},l=[{value:"Features",id:"features",children:[],level:2},{value:"Agents",id:"agents",children:[{value:"Basic Concept",id:"basic-concept",children:[],level:3},{value:"Basic Example",id:"basic-example",children:[],level:3},{value:"Human Input Mode",id:"human-input-mode",children:[],level:3},{value:"Function Calling",id:"function-calling",children:[],level:3},{value:"Notebook Examples",id:"notebook-examples",children:[],level:3}],level:2},{value:"Enhanced Inference",id:"enhanced-inference",children:[{value:"Tune Inference Parameters",id:"tune-inference-parameters",children:[{value:"Choices to optimize",id:"choices-to-optimize",children:[],level:4},{value:"Validation data",id:"validation-data",children:[],level:4},{value:"Evaluation function",id:"evaluation-function",children:[],level:4},{value:"Metric to optimize",id:"metric-to-optimize",children:[],level:4},{value:"Search space",id:"search-space",children:[],level:4},{value:"Budgets",id:"budgets",children:[],level:4},{value:"Perform tuning",id:"perform-tuning",children:[],level:4}],level:3},{value:"API unification",id:"api-unification",children:[],level:3},{value:"Caching",id:"caching",children:[],level:3},{value:"Error handling",id:"error-handling",children:[{value:"Runtime error",id:"runtime-error",children:[],level:4},{value:"Logic error",id:"logic-error",children:[],level:4}],level:3},{value:"Templating",id:"templating",children:[],level:3},{value:"Logging (Experimental)",id:"logging-experimental",children:[],level:3},{value:"Other Utilities",id:"other-utilities",children:[],level:3}],level:2},{value:"Utilities for Applications",id:"utilities-for-applications",children:[{value:"Code",id:"code",children:[],level:3},{value:"Math",id:"math",children:[],level:3}],level:2},{value:"For Further Reading",id:"for-further-reading",children:[],level:2}],p={toc:l};function c(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"autogen-enabling-next-gen-gpt-x-applications"},"AutoGen: Enabling Next-Gen GPT-X Applications"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"flaml.autogen")," simplifies the orchestration, automation and optimization of a complex GPT-X workflow. It maximizes the performance of GPT-X models and augments their weakness. It enables building next-gen GPT-X applications based on multi-agent conversations with minimal effort."),(0,i.kt)("h2",{id:"features"},"Features"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A unified multi-agent conversation framework as a high-level abstraction of using foundation models. It offers customizable and conversable agents which integrate LLM, tool and human.\nBy automating chat among multiple capable agents, one can easily make them collectively perform tasks autonomously or with human feedback, including tasks that require using tools via code."),(0,i.kt)("li",{parentName:"ul"},"A drop-in replacement of ",(0,i.kt)("inlineCode",{parentName:"li"},"openai.Completion")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"openai.ChatCompletion")," as an enhanced inference API. It allows easy performance tuning, utilities like API unification & caching, and advanced usage patterns, such as error handling, multi-config inference, context programming etc.")),(0,i.kt)("p",null,"The package is under active development with more features upcoming."),(0,i.kt)("h2",{id:"agents"},"Agents"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/reference/autogen/agentchat/agent"},(0,i.kt)("inlineCode",{parentName:"a"},"flaml.autogen.agentchat"))," offers a multi-agent conversation framework, featuring capable, customizable and conversable agents which integrate LLM, tool and human via automated agent chat."),(0,i.kt)("h3",{id:"basic-concept"},"Basic Concept"),(0,i.kt)("p",null,"We have designed a generic ",(0,i.kt)("inlineCode",{parentName:"p"},"ResponsiveAgent")," class for Agents that are capable of conversing with each other through the exchange of messages to jointly finish a task. An agent can communicate with other agents and perform actions. Different agents can differ in what actions they perform after receiving messages. Two representative subclasses are ",(0,i.kt)("inlineCode",{parentName:"p"},"AssistantAgent")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"UserProxyAgent"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AssistantAgent"),". Designed to act as an assistant by responding to user requests. It could write Python code (in a Python coding block) for a user to execute when a message (typically a description of a task that needs to be solved) is received. Under the hood, the Python code is written by LLM (e.g., GPT-4). It can also receive the execution results and suggest code with bug fix. Its behavior can be altered by passing a new system message. The LLM ",(0,i.kt)("a",{parentName:"li",href:"#enhanced-inference"},"inference")," configuration can be configured via ",(0,i.kt)("inlineCode",{parentName:"li"},"llm_config"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"UserProxyAgent"),". Serves as a proxy for the human user. Upon receiving a message, the UserProxyAgent will either solicit the human user's input or prepare an automatically generated reply. The chosen action depends on the settings of the ",(0,i.kt)("inlineCode",{parentName:"li"},"human_input_mode")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"max_consecutive_auto_reply")," when the ",(0,i.kt)("inlineCode",{parentName:"li"},"UserProxyAgent")," instance is constructed, and whether a human user input is available.\nBy default, the automatically generated reply is crafted based on automatic code execution. The ",(0,i.kt)("inlineCode",{parentName:"li"},"UserProxyAgent")," triggers code execution automatically when it detects an executable code block in the received message and no human user input is provided. Code execution can be disabled by setting ",(0,i.kt)("inlineCode",{parentName:"li"},"code_execution_config")," to False. LLM-based response is disabled by default. It can be enabled by setting ",(0,i.kt)("inlineCode",{parentName:"li"},"llm_config")," to a dict corresponding to the ",(0,i.kt)("a",{parentName:"li",href:"#enhanced-inference"},"inference")," configuration.\nWhen ",(0,i.kt)("inlineCode",{parentName:"li"},"llm_config")," is set to a dict, ",(0,i.kt)("inlineCode",{parentName:"li"},"UserProxyAgent")," can generate replies using an LLM when code execution is not performed.")),(0,i.kt)("p",null,"The auto-reply capability of ",(0,i.kt)("inlineCode",{parentName:"p"},"ResponsiveAgent")," allows for more autonomous multi-agent communication while retaining the possibility of human intervention.\nOne can also easily extend it by registering auto_reply functions with the ",(0,i.kt)("inlineCode",{parentName:"p"},"register_auto_reply()")," method."),(0,i.kt)("h3",{id:"basic-example"},"Basic Example"),(0,i.kt)("p",null,"Example usage of the agents to solve a task with code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from flaml.autogen import AssistantAgent, UserProxyAgent\n\n# create an AssistantAgent instance named "assistant"\nassistant = AssistantAgent(name="assistant")\n\n# create a UserProxyAgent instance named "user_proxy"\nuser_proxy = UserProxyAgent(\n    name="user_proxy",\n    human_input_mode="NEVER",  # in this mode, the agent will never solicit human input but always auto reply\n)\n\n# the assistant receives a message from the user, which contains the task description\nuser.initiate_chat(\n    assistant,\n    message="""What date is today? Which big tech stock has the largest year-to-date gain this year? How much is the gain?""",\n)\n')),(0,i.kt)("p",null,'In the example above, we create an AssistantAgent named "assistant" to serve as the assistant and a UserProxyAgent named "user_proxy" to serve as a proxy for the human user.'),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The assistant receives a message from the user_proxy, which contains the task description."),(0,i.kt)("li",{parentName:"ol"},"The assistant then tries to write Python code to solve the task and sends the response to the user_proxy."),(0,i.kt)("li",{parentName:"ol"},"Once the user_proxy receives a response from the assistant, it tries to reply by either soliciting human input or preparing an automatically generated reply. In this specific example, since ",(0,i.kt)("inlineCode",{parentName:"li"},"human_input_mode")," is set to ",(0,i.kt)("inlineCode",{parentName:"li"},'"NEVER"'),", the user_proxy will not solicit human input but send an automatically generated reply (auto reply). More specifically, the user_proxy executes the code and uses the result as the auto-reply."),(0,i.kt)("li",{parentName:"ol"},"The assistant then generates a further response for the user_proxy. The user_proxy can then decide whether to terminate the conversation. If not, steps 3 and 4 are repeated.")),(0,i.kt)("p",null,"Please find a visual illustration of how UserProxyAgent and AssistantAgent collaboratively solve the above task below:\n",(0,i.kt)("img",{alt:"Agent Chat Example",src:n(5705).Z})),(0,i.kt)("h3",{id:"human-input-mode"},"Human Input Mode"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"human_input_mode")," parameter of ",(0,i.kt)("inlineCode",{parentName:"p"},"UserProxyAgent")," controls the behavior of the agent when it receives a message. It can be set to ",(0,i.kt)("inlineCode",{parentName:"p"},'"NEVER"'),", ",(0,i.kt)("inlineCode",{parentName:"p"},'"ALWAYS"'),", or ",(0,i.kt)("inlineCode",{parentName:"p"},'"TERMINATE"'),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Under the mode ",(0,i.kt)("inlineCode",{parentName:"li"},'human_input_mode="NEVER"'),", the multi-turn conversation between the assistant and the user_proxy stops when the number of auto-reply reaches the upper limit specified by ",(0,i.kt)("inlineCode",{parentName:"li"},"max_consecutive_auto_reply")," or the received message is a termination message according to ",(0,i.kt)("inlineCode",{parentName:"li"},"is_termination_msg"),"."),(0,i.kt)("li",{parentName:"ul"},"When ",(0,i.kt)("inlineCode",{parentName:"li"},"human_input_mode")," is set to ",(0,i.kt)("inlineCode",{parentName:"li"},'"ALWAYS"'),', the user proxy agent solicits human input every time a message is received; and the conversation stops when the human input is "exit", or when the received message is a termination message and no human input is provided.'),(0,i.kt)("li",{parentName:"ul"},"When ",(0,i.kt)("inlineCode",{parentName:"li"},"human_input_mode")," is set to ",(0,i.kt)("inlineCode",{parentName:"li"},'"TERMINATE"'),", the user proxy agent solicits human input only when a termination message is received or the number of auto replies reaches ",(0,i.kt)("inlineCode",{parentName:"li"},"max_consecutive_auto_reply"),".")),(0,i.kt)("h3",{id:"function-calling"},"Function Calling"),(0,i.kt)("p",null,"To leverage ",(0,i.kt)("a",{parentName:"p",href:"https://openai.com/blog/function-calling-and-other-api-updates?ref=upstract.com"},"function calling capability of OpenAI's Chat Completions API"),", one can pass in a list of callable functions or class methods to ",(0,i.kt)("inlineCode",{parentName:"p"},"UserProxyAgent"),", which corresponds to the description of functions passed to OpenAI's API."),(0,i.kt)("p",null,"Example usage of the agents to solve a task with function calling feature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from flaml.autogen import AssistantAgent, UserProxyAgent\n\n# put the descriptions of functions in config to be passed to OpenAI\'s API\nllm_config = {\n    "model": "gpt-4-0613",\n    "functions": [\n        {\n            "name": "python",\n            "description": "run cell in ipython and return the execution result.",\n            "parameters": {\n                "type": "object",\n                "properties": {\n                    "cell": {\n                        "type": "string",\n                        "description": "Valid Python cell to execute.",\n                    }\n                },\n                "required": ["cell"],\n            },\n        },\n        {\n            "name": "sh",\n            "description": "run a shell script and return the execution result.",\n            "parameters": {\n                "type": "object",\n                "properties": {\n                    "script": {\n                        "type": "string",\n                        "description": "Valid shell script to execute.",\n                    }\n                },\n                "required": ["script"],\n            },\n        },\n    ],\n}\n\n# create an AssistantAgent instance named "assistant"\nchatbot = AssistantAgent("assistant", **llm_config)\n\n# create a UserProxyAgent instance named "user_proxy"\nuser_proxy = UserProxyAgent(\n    "user_proxy",\n    human_input_mode="NEVER",\n)\n\n# define functions according to the function desription\nfrom IPython import get_ipython\n\ndef exec_python(cell):\n    ipython = get_ipython()\n    result = ipython.run_cell(cell)\n    log = str(result.result)\n    if result.error_before_exec is not None:\n        log += f"\\n{result.error_before_exec}"\n    if result.error_in_exec is not None:\n        log += f"\\n{result.error_in_exec}"\n    return log\n\ndef exec_sh(script):\n    return user_proxy.execute_code_blocks([("sh", script)])\n\n# register the functions\nuser_proxy.register_function(\n    function_map={\n        "python": exec_python,\n        "sh": exec_sh,\n    }\n)\n\n# start the conversation\nuser_proxy.initiate_chat(\n    chatbot,\n    message="Draw two agents chatting with each other with an example dialog.",\n)\n')),(0,i.kt)("h3",{id:"notebook-examples"},"Notebook Examples"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Interested in trying it yourself? Please check the following notebook examples:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/blob/main/notebook/autogen_agentchat_auto_feedback_from_code_execution.ipynb"},"Automated Task Solving with Code Generation, Execution & Debugging")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/blob/main/notebook/autogen_agentchat_human_feedback.ipynb"},"Auto Code Generation, Execution, Debugging and Human Feedback")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/blob/main/notebook/autogen_agentchat_web_info.ipynb"},"Solve Tasks Requiring Web Info")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/blob/main/notebook/autogen_agentchat_function_call.ipynb"},"Use Provided Tools as Functions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/blob/main/notebook/autogen_agentchat_planning.ipynb"},"Automated Task Solving with Coding & Planning Agents")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/blob/main/notebook/autogen_agentchat_two_users.ipynb"},"Automated Task Solving with GPT-4 + Multiple Human Users")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/blob/main/notebook/autogen_agentchat_chess.ipynb"},"Automated Chess Game Playing & Chitchatting by GPT-4 Agents")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/blob/main/notebook/autogen_agentchat_groupchat.ipynb"},"Automated Task Solving by Group Chat")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/blob/main/notebook/autogen_agentchat_stream.ipynb"},"Automated Continual Learning from New Data")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/blob/main/notebook/autogen_agentchat_RetrieveChat.ipynb"},"Automated Code Generation and Question Answering with Retrieval Augemented Agents"))),(0,i.kt)("h2",{id:"enhanced-inference"},"Enhanced Inference"),(0,i.kt)("p",null,"One can use ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/autogen/oai/completion#create"},(0,i.kt)("inlineCode",{parentName:"a"},"flaml.autogen.Completion.create"))," to perform inference.\nThere are a number of benefits of using ",(0,i.kt)("inlineCode",{parentName:"p"},"autogen")," to perform inference: performance tuning, API unification, caching, error handling, multi-config inference, result filtering, templating and so on."),(0,i.kt)("h3",{id:"tune-inference-parameters"},"Tune Inference Parameters"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Links to notebook examples:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/blob/main/notebook/autogen_openai_completion.ipynb"},"Optimize for Code Generation")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/microsoft/FLAML/blob/main/notebook/autogen_chatgpt_gpt4.ipynb"},"Optimize for Math"))),(0,i.kt)("h4",{id:"choices-to-optimize"},"Choices to optimize"),(0,i.kt)("p",null,"The cost of using foundation models for text generation is typically measured in terms of the number of tokens in the input and output combined. From the perspective of an application builder using foundation models, the use case is to maximize the utility of the generated text under an inference budget constraint (e.g., measured by the average dollar cost needed to solve a coding problem). This can be achieved by optimizing the hyperparameters of the inference,\nwhich can significantly affect both the utility and the cost of the generated text."),(0,i.kt)("p",null,"The tunable hyperparameters include:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"model - this is a required input, specifying the model ID to use."),(0,i.kt)("li",{parentName:"ol"},"prompt/messages - the input prompt/messages to the model, which provides the context for the text generation task."),(0,i.kt)("li",{parentName:"ol"},"max_tokens - the maximum number of tokens (words or word pieces) to generate in the output."),(0,i.kt)("li",{parentName:"ol"},"temperature - a value between 0 and 1 that controls the randomness of the generated text. A higher temperature will result in more random and diverse text, while a lower temperature will result in more predictable text."),(0,i.kt)("li",{parentName:"ol"},"top_p - a value between 0 and 1 that controls the sampling probability mass for each token generation. A lower top_p value will make it more likely to generate text based on the most likely tokens, while a higher value will allow the model to explore a wider range of possible tokens."),(0,i.kt)("li",{parentName:"ol"},"n - the number of responses to generate for a given prompt. Generating multiple responses can provide more diverse and potentially more useful output, but it also increases the cost of the request."),(0,i.kt)("li",{parentName:"ol"},"stop - a list of strings that, when encountered in the generated text, will cause the generation to stop. This can be used to control the length or the validity of the output."),(0,i.kt)("li",{parentName:"ol"},"presence_penalty, frequency_penalty - values that control the relative importance of the presence and frequency of certain words or phrases in the generated text."),(0,i.kt)("li",{parentName:"ol"},'best_of - the number of responses to generate server-side when selecting the "best" (the one with the highest log probability per token) response for a given prompt.')),(0,i.kt)("p",null,"The cost and utility of text generation are intertwined with the joint effect of these hyperparameters.\nThere are also complex interactions among subsets of the hyperparameters. For example,\nthe temperature and top_p are not recommended to be altered from their default values together because they both control the randomness of the generated text, and changing both at the same time can result in conflicting effects; n and best_of are rarely tuned together because if the application can process multiple outputs, filtering on the server side causes unnecessary information loss; both n and max_tokens will affect the total number of tokens generated, which in turn will affect the cost of the request.\nThese interactions and trade-offs make it difficult to manually determine the optimal hyperparameter settings for a given text generation task."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Do the choices matter? Check this ",(0,i.kt)("a",{parentName:"em",href:"/blog/2023/04/21/LLM-tuning-math"},"blogpost")," to find example tuning results about gpt-3.5-turbo and gpt-4.")),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"flaml.autogen"),", the tuning can be performed with the following information:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Validation data."),(0,i.kt)("li",{parentName:"ol"},"Evaluation function."),(0,i.kt)("li",{parentName:"ol"},"Metric to optimize."),(0,i.kt)("li",{parentName:"ol"},"Search space."),(0,i.kt)("li",{parentName:"ol"},"Budgets: inference and optimization respectively.")),(0,i.kt)("h4",{id:"validation-data"},"Validation data"),(0,i.kt)("p",null,'Collect a diverse set of instances. They can be stored in an iterable of dicts. For example, each instance dict can contain "problem" as a key and the description str of a math problem as the value; and "solution" as a key and the solution str as the value.'),(0,i.kt)("h4",{id:"evaluation-function"},"Evaluation function"),(0,i.kt)("p",null,"The evaluation function should take a list of responses, and other keyword arguments corresponding to the keys in each validation data instance as input, and output a dict of metrics. For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def eval_math_responses(responses: List[str], solution: str, **args) -> Dict:\n    # select a response from the list of responses\n    answer = voted_answer(responses)\n    # check whether the answer is correct\n    return {"success": is_equivalent(answer, solution)}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/reference/autogen/code_utils"},(0,i.kt)("inlineCode",{parentName:"a"},"flaml.autogen.code_utils"))," and ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/autogen/math_utils"},(0,i.kt)("inlineCode",{parentName:"a"},"flaml.autogen.math_utils"))," offer some example evaluation functions for code generation and math problem solving."),(0,i.kt)("h4",{id:"metric-to-optimize"},"Metric to optimize"),(0,i.kt)("p",null,'The metric to optimize is usually an aggregated metric over all the tuning data instances. For example, users can specify "success" as the metric and "max" as the optimization mode. By default, the aggregation function is taking the average. Users can provide a customized aggregation function if needed.'),(0,i.kt)("h4",{id:"search-space"},"Search space"),(0,i.kt)("p",null,"Users can specify the (optional) search range for each hyperparameter."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"model. Either a constant str, or multiple choices specified by ",(0,i.kt)("inlineCode",{parentName:"li"},"flaml.tune.choice"),"."),(0,i.kt)("li",{parentName:"ol"},'prompt/messages. Prompt is either a str or a list of strs, of the prompt templates. messages is a list of dicts or a list of lists, of the message templates.\nEach prompt/message template will be formatted with each data instance. For example, the prompt template can be:\n"{problem} Solve the problem carefully. Simplify your answer as much as possible. Put the final answer in ',"\\",'boxed{{}}."\nAnd ',(0,i.kt)("inlineCode",{parentName:"li"},"{problem}"),' will be replaced by the "problem" field of each data instance.'),(0,i.kt)("li",{parentName:"ol"},"max_tokens, n, best_of. They can be constants, or specified by ",(0,i.kt)("inlineCode",{parentName:"li"},"flaml.tune.randint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"flaml.tune.qrandint"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"flaml.tune.lograndint")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"flaml.qlograndint"),". By default, max_tokens is searched in [50, 1000); n is searched in [1, 100); and best_of is fixed to 1."),(0,i.kt)("li",{parentName:"ol"},"stop. It can be a str or a list of strs, or a list of lists of strs or None. Default is None."),(0,i.kt)("li",{parentName:"ol"},"temperature or top_p. One of them can be specified as a constant or by ",(0,i.kt)("inlineCode",{parentName:"li"},"flaml.tune.uniform")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"flaml.tune.loguniform")," etc.\nPlease don't provide both. By default, each configuration will choose either a temperature or a top_p in ","[0, 1]"," uniformly."),(0,i.kt)("li",{parentName:"ol"},"presence_penalty, frequency_penalty. They can be constants or specified by ",(0,i.kt)("inlineCode",{parentName:"li"},"flaml.tune.uniform")," etc. Not tuned by default.")),(0,i.kt)("h4",{id:"budgets"},"Budgets"),(0,i.kt)("p",null,"One can specify an inference budget and an optimization budget.\nThe inference budget refers to the average inference cost per data instance.\nThe optimization budget refers to the total budget allowed in the tuning process. Both are measured by dollars and follow the price per 1000 tokens."),(0,i.kt)("h4",{id:"perform-tuning"},"Perform tuning"),(0,i.kt)("p",null,"Now, you can use ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/autogen/oai/completion#tune"},(0,i.kt)("inlineCode",{parentName:"a"},"flaml.autogen.Completion.tune"))," for tuning. For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from flaml import autogen\n\nconfig, analysis = autogen.Completion.tune(\n    data=tune_data,\n    metric="success",\n    mode="max",\n    eval_func=eval_func,\n    inference_budget=0.05,\n    optimization_budget=3,\n    num_samples=-1,\n)\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"num_samples")," is the number of configurations to sample. -1 means unlimited (until optimization budget is exhausted).\nThe returned ",(0,i.kt)("inlineCode",{parentName:"p"},"config")," contains the optimized configuration and ",(0,i.kt)("inlineCode",{parentName:"p"},"analysis")," contains an ",(0,i.kt)("a",{parentName:"p",href:"/docs/reference/tune/analysis#experimentanalysis-objects"},"ExperimentAnalysis")," object for all the tried configurations and results."),(0,i.kt)("p",null,"The tuend config can be used to perform inference."),(0,i.kt)("h3",{id:"api-unification"},"API unification"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"flaml.autogen.Completion.create")," is compatible with both ",(0,i.kt)("inlineCode",{parentName:"p"},"openai.Completion.create")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"openai.ChatCompletion.create"),', and both OpenAI API and Azure OpenAI API. So models such as "text-davinci-003", "gpt-3.5-turbo" and "gpt-4" can share a common API.\nWhen chat models are used and ',(0,i.kt)("inlineCode",{parentName:"p"},"prompt")," is given as the input to ",(0,i.kt)("inlineCode",{parentName:"p"},"flaml.autogen.Completion.create"),", the prompt will be automatically converted into ",(0,i.kt)("inlineCode",{parentName:"p"},"messages")," to fit the chat completion API requirement. One advantage is that one can experiment with both chat and non-chat models for the same prompt in a unified API."),(0,i.kt)("p",null,"For local LLMs, one can spin up an endpoint using a package like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lhenault/simpleAI"},"simple_ai_server")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/lm-sys/FastChat"},"FastChat"),", and then use the same API to send a request. See ",(0,i.kt)("a",{parentName:"p",href:"/blog/2023/07/14/Local-LLMs"},"here")," for examples on how to make inference with local LLMs."),(0,i.kt)("p",null,"When only working with the chat-based models, ",(0,i.kt)("inlineCode",{parentName:"p"},"flaml.autogen.ChatCompletion")," can be used. It also does automatic conversion from prompt to messages, if prompt is provided instead of messages."),(0,i.kt)("h3",{id:"caching"},"Caching"),(0,i.kt)("p",null,'API call results are cached locally and reused when the same request is issued. This is useful when repeating or continuing experiments for reproducibility and cost saving. It still allows controlled randomness by setting the "seed", using ',(0,i.kt)("a",{parentName:"p",href:"/docs/reference/autogen/oai/completion#set_cache"},(0,i.kt)("inlineCode",{parentName:"a"},"set_cache"))," or specifying in ",(0,i.kt)("inlineCode",{parentName:"p"},"create()"),"."),(0,i.kt)("h3",{id:"error-handling"},"Error handling"),(0,i.kt)("h4",{id:"runtime-error"},"Runtime error"),(0,i.kt)("p",null,"It is easy to hit error when calling OpenAI APIs, due to connection, rate limit, or timeout. Some of the errors are transient. ",(0,i.kt)("inlineCode",{parentName:"p"},"flaml.autogen.Completion.create")," deals with the transient errors and retries automatically. Initial request timeout, retry timeout and retry time interval can be configured via ",(0,i.kt)("inlineCode",{parentName:"p"},"request_timeout"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"retry_timeout")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"flaml.autogen.Completion.retry_time"),"."),(0,i.kt)("p",null,"Moreover, one can pass a list of configurations of different models/endpoints to mitigate the rate limits. For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'response = autogen.Completion.create(\n    config_list=[\n        {\n            "model": "gpt-4",\n            "api_key": os.environ.get("AZURE_OPENAI_API_KEY"),\n            "api_type": "azure",\n            "api_base": os.environ.get("AZURE_OPENAI_API_BASE"),\n            "api_version": "2023-06-01-preview",\n        },\n        {\n            "model": "gpt-3.5-turbo",\n            "api_key": os.environ.get("OPENAI_API_KEY"),\n            "api_type": "open_ai",\n            "api_base": "https://api.openai.com/v1",\n            "api_version": None,\n        },\n        {\n            "model": "llama-7B",\n            "api_base": "http://127.0.0.1:8080",\n            "api_type": "open_ai",\n            "api_version": None,\n        }\n    ],\n    prompt="Hi",\n)\n')),(0,i.kt)("p",null,"It will try querying Azure OpenAI gpt-4, OpenAI gpt-3.5-turbo, and a locally hosted llama-7B one by one, ignoring AuthenticationError, RateLimitError and Timeout,\nuntil a valid result is returned. This can speed up the development process where the rate limit is a bottleneck. An error will be raised if the last choice fails. So make sure the last choice in the list has the best availability."),(0,i.kt)("h4",{id:"logic-error"},"Logic error"),(0,i.kt)("p",null,"Another type of error is that the returned response does not satisfy a requirement. For example, if the response is required to be a valid json string, one would like to filter the responses that are not. This can be achieved by providing a list of configurations and a filter function. For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def valid_json_filter(context, config, response):\n    for text in autogen.Completion.extract_text(response):\n        try:\n            json.loads(text)\n            return True\n        except ValueError:\n            pass\n    return False\n\nresponse = autogen.Completion.create(\n    config_list=[{"model": "text-ada-001"}, {"model": "gpt-3.5-turbo"}, {"model": "text-davinci-003"}],\n    prompt="How to construct a json request to Bing API to search for \'latest AI news\'? Return the JSON request.",\n    filter_func=valid_json_filter,\n)\n')),(0,i.kt)("p",null,"The example above will try to use text-ada-001, gpt-3.5-turbo, and text-davinci-003 iteratively, until a valid json string is returned or the last config is used. One can also repeat the same model in the list for multiple times to try one model multiple times for increasing the robustness of the final response."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Advanced use case: Check this ",(0,i.kt)("a",{parentName:"em",href:"/blog/2023/05/18/GPT-adaptive-humaneval"},"blogpost")," to find how to improve GPT-4's coding performance from 68% to 90% while reducing the inference cost.")),(0,i.kt)("h3",{id:"templating"},"Templating"),(0,i.kt)("p",null,"If the provided prompt or message is a template, it will be automatically materialized with a given context. For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'response = autogen.Completion.create(\n    context={"problem": "How many positive integers, not exceeding 100, are multiples of 2 or 3 but not 4?"},\n    prompt="{problem} Solve the problem carefully.",\n    allow_format_str_template=True,\n    **config\n)\n')),(0,i.kt)("p",null,"A template is either a format str, like the example above, or a function which produces a str from several input fields, like the example below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def content(turn, context):\n    return "\\n".join(\n        [\n            context[f"user_message_{turn}"],\n            context[f"external_info_{turn}"]\n        ]\n    )\n\nmessages = [\n    {\n        "role": "system",\n        "content": "You are a teaching assistant of math.",\n    },\n    {\n        "role": "user",\n        "content": partial(content, turn=0),\n    },\n]\ncontext = {\n    "user_message_0": "Could you explain the solution to Problem 1?",\n    "external_info_0": "Problem 1: ...",\n}\n\nresponse = autogen.ChatCompletion.create(context, messages=messages, **config)\nmessages.append(\n    {\n        "role": "assistant",\n        "content": autogen.ChatCompletion.extract_text(response)[0]\n    }\n)\nmessages.append(\n    {\n        "role": "user",\n        "content": partial(content, turn=1),\n    },\n)\ncontext.append(\n    {\n        "user_message_1": "Why can\'t we apply Theorem 1 to Equation (2)?",\n        "external_info_1": "Theorem 1: ...",\n    }\n)\nresponse = autogen.ChatCompletion.create(context, messages=messages, **config)\n')),(0,i.kt)("h3",{id:"logging-experimental"},"Logging (Experimental)"),(0,i.kt)("p",null,"When debugging or diagnosing an LLM-based system, it is often convenient to log the API calls and analyze them. ",(0,i.kt)("inlineCode",{parentName:"p"},"flaml.autogen.Completion")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"flaml.autogen.ChatCompletion")," offer an easy way to collect the API call histories. For example, to log the chat histories, simply run:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"flaml.autogen.ChatCompletion.start_logging()\n")),(0,i.kt)("p",null,"The API calls made after this will be automatically logged. They can be retrieved at any time by:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"flaml.autogen.ChatCompletion.logged_history\n")),(0,i.kt)("p",null,"To stop logging, use"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"flaml.autogen.ChatCompletion.stop_logging()\n")),(0,i.kt)("p",null,"If one would like to append the history to an existing dict, pass the dict like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"flaml.autogen.ChatCompletion.start_logging(history_dict=existing_history_dict)\n")),(0,i.kt)("p",null,"By default, the counter of API calls will be reset at ",(0,i.kt)("inlineCode",{parentName:"p"},"start_logging()"),". If no reset is desired, set ",(0,i.kt)("inlineCode",{parentName:"p"},"reset_counter=False"),"."),(0,i.kt)("p",null,"There are two types of logging formats: compact logging and individual API call logging. The default format is compact.\nSet ",(0,i.kt)("inlineCode",{parentName:"p"},"compact=False")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"start_logging()")," to switch."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Example of a history dict with compact logging.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"{\n    \"\"\"\n    [\n        {\n            'role': 'system',\n            'content': system_message,\n        },\n        {\n            'role': 'user',\n            'content': user_message_1,\n        },\n        {\n            'role': 'assistant',\n            'content': assistant_message_1,\n        },\n        {\n            'role': 'user',\n            'content': user_message_2,\n        },\n        {\n            'role': 'assistant',\n            'content': assistant_message_2,\n        },\n    ]\"\"\": {\n        \"created_at\": [0, 1],\n        \"cost\": [0.1, 0.2],\n    }\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Example of a history dict with individual API call logging.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'{\n    0: {\n        "request": {\n            "messages": [\n                {\n                    "role": "system",\n                    "content": system_message,\n                },\n                {\n                    "role": "user",\n                    "content": user_message_1,\n                }\n            ],\n            ... # other parameters in the request\n        },\n        "response": {\n            "choices": [\n                "messages": {\n                    "role": "assistant",\n                    "content": assistant_message_1,\n                },\n            ],\n            ... # other fields in the response\n        }\n    },\n    1: {\n        "request": {\n            "messages": [\n                {\n                    "role": "system",\n                    "content": system_message,\n                },\n                {\n                    "role": "user",\n                    "content": user_message_1,\n                },\n                {\n                    "role": "assistant",\n                    "content": assistant_message_1,\n                },\n                {\n                    "role": "user",\n                    "content": user_message_2,\n                },\n            ],\n            ... # other parameters in the request\n        },\n        "response": {\n            "choices": [\n                "messages": {\n                    "role": "assistant",\n                    "content": assistant_message_2,\n                },\n            ],\n            ... # other fields in the response\n        }\n    },\n}\n')),(0,i.kt)("p",null,"It can be seen that the individual API call history contains redundant information of the conversation. For a long conversation the degree of redundancy is high.\nThe compact history is more efficient and the individual API call history contains more details."),(0,i.kt)("h3",{id:"other-utilities"},"Other Utilities"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("a",{parentName:"li",href:"/docs/reference/autogen/oai/completion#cost"},(0,i.kt)("inlineCode",{parentName:"a"},"cost"))," function to calculate the cost of an API call."),(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("a",{parentName:"li",href:"/docs/reference/autogen/oai/completion#test"},(0,i.kt)("inlineCode",{parentName:"a"},"test"))," function to conveniently evaluate the configuration over test data."),(0,i.kt)("li",{parentName:"ul"},"an ",(0,i.kt)("a",{parentName:"li",href:"/docs/reference/autogen/oai/completion#extract_text_or_function_call"},(0,i.kt)("inlineCode",{parentName:"a"},"extract_text_or_function_call"))," function to extract the text or function call from a completion or chat response.")),(0,i.kt)("h2",{id:"utilities-for-applications"},"Utilities for Applications"),(0,i.kt)("h3",{id:"code"},"Code"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/reference/autogen/code_utils"},(0,i.kt)("inlineCode",{parentName:"a"},"flaml.autogen.code_utils"))," offers code-related utilities, such as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("a",{parentName:"li",href:"/docs/reference/autogen/code_utils#improve_code"},(0,i.kt)("inlineCode",{parentName:"a"},"improve_code"))," function to improve code for a given objective."),(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("a",{parentName:"li",href:"/docs/reference/autogen/code_utils#generate_assertions"},(0,i.kt)("inlineCode",{parentName:"a"},"generate_assertions"))," function to generate assertion statements from function signature and docstr."),(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("a",{parentName:"li",href:"/docs/reference/autogen/code_utils#implement"},(0,i.kt)("inlineCode",{parentName:"a"},"implement"))," function to implement a function from a definition."),(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("a",{parentName:"li",href:"/docs/reference/autogen/code_utils#eval_function_completions"},(0,i.kt)("inlineCode",{parentName:"a"},"eval_function_completions"))," function to evaluate the success of a function completion task, or select a response from a list of responses using generated assertions.")),(0,i.kt)("h3",{id:"math"},"Math"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/docs/reference/autogen/math_utils"},(0,i.kt)("inlineCode",{parentName:"a"},"flaml.autogen.math_utils"))," offers utilities for math problems, such as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("a",{parentName:"li",href:"/docs/reference/autogen/math_utils#eval_math_responses"},"eval_math_responses")," function to select a response using voting, and check if the final answer is correct if the canonical solution is provided.")),(0,i.kt)("h2",{id:"for-further-reading"},"For Further Reading"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Interested in the research that leads to this package? Please check the following papers.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://arxiv.org/abs/2303.04673"},"Cost-Effective Hyperparameter Optimization for Large Language Model Generation Inference"),". Chi Wang, Susan Xueqing Liu, Ahmed H. Awadallah. ArXiv preprint arXiv:2303.04673 (2023)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://arxiv.org/abs/2306.01337"},"An Empirical Study on Challenging Math Problem Solving with GPT-4"),". Yiran Wu, Feiran Jia, Shaokun Zhang, Hangyu Li, Erkang Zhu, Yue Wang, Yin Tat Lee, Richard Peng, Qingyun Wu, Chi Wang. ArXiv preprint arXiv:2306.01337 (2023)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://arxiv.org/abs/2308.08155"},"AutoGen: Enabling Next-Gen LLM Applications via Multi-Agent Conversation Framework"),". Qingyun Wu, Gagan Bansal, Jieyu Zhang, Yiran Wu, Shaokun Zhang, Erkang Zhu, Beibin Li, Li Jiang, Xiaoyun Zhang, Chi Wang. ArXiv preprint arXiv:2308.08155 (2023).")))}c.isMDXComponent=!0},5705:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/agent_example-a965f253ce7d8e1548ff819e19edc5e4.png"}}]);