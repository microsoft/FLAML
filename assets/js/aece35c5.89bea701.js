"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3372],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>k});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=p(a),k=i,c=u["".concat(o,".").concat(k)]||u[k]||d[k]||r;return a?n.createElement(c,l(l({ref:t},m),{},{components:a})):n.createElement(c,l({ref:t},m))}));function k(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=u;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:i,l[1]=s;for(var p=2;p<r;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},1174:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>o});var n=a(7462),i=(a(7294),a(3905));const r={sidebar_label:"task",title:"automl.task.task"},l=void 0,s={unversionedId:"reference/automl/task/task",id:"reference/automl/task/task",isDocsHomePage:!1,title:"automl.task.task",description:"Task Objects",source:"@site/docs/reference/automl/task/task.md",sourceDirName:"reference/automl/task",slug:"/reference/automl/task/task",permalink:"/FLAML/docs/reference/automl/task/task",editUrl:"https://github.com/microsoft/FLAML/edit/main/website/docs/reference/automl/task/task.md",tags:[],version:"current",frontMatter:{sidebar_label:"task",title:"automl.task.task"},sidebar:"referenceSideBar",previous:{title:"utils",permalink:"/FLAML/docs/reference/automl/spark/utils"},next:{title:"time_series_task",permalink:"/FLAML/docs/reference/automl/task/time_series_task"}},o=[{value:"Task Objects",id:"task-objects",children:[{value:"__init__",id:"__init__",children:[],level:4},{value:"__str__",id:"__str__",children:[],level:4},{value:"evaluate_model_CV",id:"evaluate_model_cv",children:[],level:4},{value:"validate_data",id:"validate_data",children:[],level:4},{value:"prepare_data",id:"prepare_data",children:[],level:4},{value:"decide_split_type",id:"decide_split_type",children:[],level:4},{value:"preprocess",id:"preprocess",children:[],level:4},{value:"default_estimator_list",id:"default_estimator_list",children:[],level:4},{value:"default_metric",id:"default_metric",children:[],level:4},{value:"__eq__",id:"__eq__",children:[],level:4},{value:"estimator_class_from_str",id:"estimator_class_from_str",children:[],level:4}],level:2}],p={toc:o};function m(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"task-objects"},"Task Objects"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class Task(ABC)\n")),(0,i.kt)("p",null,"Abstract base class for a machine learning task."),(0,i.kt)("p",null,"Class definitions should implement abstract methods and provide a non-empty dictionary of estimator classes.\nA Task can be suitable to be used for multiple machine-learning tasks (e.g. classification or regression) or be\nimplemented specifically for a single one depending on the generality of data validation and model evaluation methods\nimplemented. The implementation of a Task may optionally use the training data and labels to determine data and task\nspecific details, such as in determining if a problem is single-label or multi-label."),(0,i.kt)("p",null,"FLAML evaluates at runtime how to behave exactly, relying on the task instance to provide implementations of\noperations which vary between tasks."),(0,i.kt)("h4",{id:"__init__"},"_","_","init","_","_"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def __init__(task_name: str, X_train: Optional[Union[np.ndarray, DataFrame, psDataFrame]] = None, y_train: Optional[Union[np.ndarray, DataFrame, Series, psSeries]] = None)\n")),(0,i.kt)("p",null,"Constructor."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"task_name")," - String name for this type of task. Used when the Task can be generic and implement a number of\ntypes of sub-task."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"X_train")," - Optional. Some Task types may use the data shape or features to determine details of their usage,\nsuch as in binary vs multilabel classification."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"y_train")," - Optional. Some Task types may use the data shape or features to determine details of their usage,\nsuch as in binary vs multilabel classification.")),(0,i.kt)("h4",{id:"__str__"},"_","_","str","_","_"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def __str__() -> str\n")),(0,i.kt)("p",null,"Name of this task type."),(0,i.kt)("h4",{id:"evaluate_model_cv"},"evaluate","_","model","_","CV"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'@abstractmethod\ndef evaluate_model_CV(config: dict, estimator: "flaml.automl.ml.BaseEstimator", X_train_all: Union[np.ndarray, DataFrame, psDataFrame], y_train_all: Union[np.ndarray, DataFrame, Series, psSeries], budget: int, kf, eval_metric: str, best_val_loss: float, log_training_metric: bool = False, fit_kwargs: Optional[dict] = {}) -> Tuple[float, float, float, float]\n')),(0,i.kt)("p",null,"Evaluate the model using cross-validation."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"config")," - configuration used in the evaluation of the metric."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"estimator")," - Estimator class of the model."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"X_train_all")," - Complete training feature data."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"y_train_all")," - Complete training target data."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"budget")," - Training time budget."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"kf")," - Cross-validation index generator."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"eval_metric")," - Metric name to be used for evaluation."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"best_val_loss")," - Best current validation-set loss."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"log_training_metric")," - Bool defaults False. Enables logging of the training metric."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fit_kwargs")," - Additional kwargs passed to the estimator's fit method.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns"),":"),(0,i.kt)("p",null,"  validation loss, metric value, train time, prediction time"),(0,i.kt)("h4",{id:"validate_data"},"validate","_","data"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'@abstractmethod\ndef validate_data(automl: "flaml.automl.automl.AutoML", state: "flaml.automl.state.AutoMLState", X_train_all: Union[np.ndarray, DataFrame, psDataFrame, None], y_train_all: Union[np.ndarray, DataFrame, Series, psSeries, None], dataframe: Union[DataFrame, None], label: str, X_val: Optional[Union[np.ndarray, DataFrame, psDataFrame]] = None, y_val: Optional[Union[np.ndarray, DataFrame, Series, psSeries]] = None, groups_val: Optional[List[str]] = None, groups: Optional[List[str]] = None)\n')),(0,i.kt)("p",null,"Validate that the data is suitable for this task type."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"automl")," - The AutoML instance from which this task has been constructed."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state")," - The AutoMLState instance for this run."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"X_train_all")," - The complete data set or None if dataframe is supplied."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"y_train_all")," - The complete target set or None if dataframe is supplied."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dataframe")," - A dataframe constaining the complete data set with targets."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"label")," - The name of the target column in dataframe."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"X_val")," - Optional. A data set for validation."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"y_val")," - Optional. A target vector corresponding to X_val for validation."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"groups_val")," - Group labels (with matching length to y_val) or group counts (with sum equal to length of y_val)\nfor validation data. Need to be consistent with groups."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"groups")," - Group labels (with matching length to y_train) or groups counts (with sum equal to length of y_train)\nfor training data.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Raises"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AssertionError")," - The data provided is invalid for this task type and configuration.")),(0,i.kt)("h4",{id:"prepare_data"},"prepare","_","data"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'@abstractmethod\ndef prepare_data(state: "flaml.automl.state.AutoMLState", X_train_all: Union[np.ndarray, DataFrame, psDataFrame], y_train_all: Union[np.ndarray, DataFrame, Series, psSeries, None], auto_augment: bool, eval_method: str, split_type: str, split_ratio: float, n_splits: int, data_is_df: bool, sample_weight_full: Optional[List[float]] = None)\n')),(0,i.kt)("p",null,"Prepare the data for fitting or inference."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"automl")," - The AutoML instance from which this task has been constructed."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state")," - The AutoMLState instance for this run."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"X_train_all")," - The complete data set or None if dataframe is supplied. Must\ncontain the target if y_train_all is None"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"y_train_all")," - The complete target set or None if supplied in X_train_all."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"auto_augment")," - If true, task-specific data augmentations will be applied."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"eval_method")," - A string of resampling strategy, one of ","['auto', 'cv', 'holdout']","."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"split_type"),' - str or splitter object, default="auto" | the data split type.',(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"A valid splitter object is an instance of a derived class of scikit-learn\n",(0,i.kt)("a",{parentName:"li",href:"https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html#sklearn.model_selection.KFold"},"KFold"),"\nand have ",(0,i.kt)("inlineCode",{parentName:"li"},"split")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"get_n_splits"),' methods with the same signatures.\nSet eval_method to "cv" to use the splitter object.'),(0,i.kt)("li",{parentName:"ul"},"Valid str options depend on different tasks.\nFor classification tasks, valid choices are\n","[\"auto\", 'stratified', 'uniform', 'time', 'group']",'. "auto" -> stratified.\nFor regression tasks, valid choices are ',"[\"auto\", 'uniform', 'time']",'.\n"auto" -> uniform.\nFor time series forecast tasks, must be "auto" or \'time\'.\nFor ranking task, must be "auto" or \'group\'.'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"split_ratio")," - A float of the valiation data percentage for holdout."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"n_splits")," - An integer of the number of folds for cross - validation."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data_is_df")," - True if the data was provided as a DataFrame else False."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sample_weight_full")," - A 1d arraylike of the sample weight.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Raises"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AssertionError")," - The configuration provided is invalid for this task type and data.")),(0,i.kt)("h4",{id:"decide_split_type"},"decide","_","split","_","type"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef decide_split_type(split_type: str, y_train_all: Union[np.ndarray, DataFrame, Series, psSeries, None], fit_kwargs: dict, groups: Optional[List[str]] = None) -> str\n")),(0,i.kt)("p",null,"Choose an appropriate data split type for this data and task."),(0,i.kt)("p",null,"If split_type is 'auto' then this is determined based on the task type and data.\nIf a specific split_type is requested then the choice is validated to be appropriate."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"split_type")," - Either 'auto' or a task appropriate split type."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"y_train_all")," - The complete set of targets."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fit_kwargs")," - Additional kwargs passed to the estimator's fit method."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"groups")," - Optional. Group labels (with matching length to y_train) or groups counts (with sum equal to length\nof y_train) for training data.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns"),":"),(0,i.kt)("p",null,"  The determined appropriate split type."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Raises"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AssertionError")," - The requested split_type is invalid for this task, configuration and data.")),(0,i.kt)("h4",{id:"preprocess"},"preprocess"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'@abstractmethod\ndef preprocess(X: Union[np.ndarray, DataFrame, psDataFrame], transformer: Optional["flaml.automl.data.DataTransformer"] = None) -> Union[np.ndarray, DataFrame]\n')),(0,i.kt)("p",null,"Preprocess the data ready for fitting or inference with this task type."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"X")," - The data set to process."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"transformer")," - A DataTransformer instance to be used in processing.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns"),":"),(0,i.kt)("p",null,"  The preprocessed data set having the same type as the input."),(0,i.kt)("h4",{id:"default_estimator_list"},"default","_","estimator","_","list"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'@abstractmethod\ndef default_estimator_list(estimator_list: Union[List[str], str] = "auto", is_spark_dataframe: bool = False) -> List[str]\n')),(0,i.kt)("p",null,"Return the list of default estimators registered for this task type."),(0,i.kt)("p",null,"If 'auto' is provided then the default list is returned, else the provided list will be validated given this task\ntype."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"estimator_list")," - Either 'auto' or a list of estimator names to be validated."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"is_spark_dataframe")," - True if the data is a spark dataframe.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns"),":"),(0,i.kt)("p",null,"  A list of valid estimator names for this task type."),(0,i.kt)("h4",{id:"default_metric"},"default","_","metric"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"@abstractmethod\ndef default_metric(metric: str) -> str\n")),(0,i.kt)("p",null,"Return the default metric for this task type."),(0,i.kt)("p",null,"If 'auto' is provided then the default metric for this task will be returned. Otherwise, the provided metric name\nis validated for this task type."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"metric")," - The name of a metric to be used in evaluation of models during fitting or validation.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns"),":"),(0,i.kt)("p",null,"  The default metric, or the provided metric if it is valid for this task type."),(0,i.kt)("h4",{id:"__eq__"},"_","_","eq","_","_"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def __eq__(other: str) -> bool\n")),(0,i.kt)("p",null,"For backward compatibility with all the string comparisons to task"),(0,i.kt)("h4",{id:"estimator_class_from_str"},"estimator","_","class","_","from","_","str"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def estimator_class_from_str(estimator_name: str) -> "flaml.automl.ml.BaseEstimator"\n')),(0,i.kt)("p",null,"Determine the estimator class corresponding to the provided name."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"estimator_name")," - Name of the desired estimator.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns"),":"),(0,i.kt)("p",null,"  The estimator class corresponding to the provided name."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Raises"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ValueError")," - The provided estimator_name has not been registered for this task type.")))}m.isMDXComponent=!0}}]);