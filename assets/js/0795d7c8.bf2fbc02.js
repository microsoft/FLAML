"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3804],{5680(e,n,t){t.d(n,{xA:()=>p,yg:()=>g});var r=t(6540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),s=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=s(e.components);return r.createElement(c.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(t),g=o,d=u["".concat(c,".").concat(g)]||u[g]||m[g]||i;return t?r.createElement(d,a(a({ref:n},p),{},{components:t})):r.createElement(d,a({ref:n},p))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=u;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var s=2;s<i;s++)a[s]=t[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},7473(e,n,t){t.r(n),t.d(n,{contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=t(8168),o=(t(6540),t(5680));const i={sidebar_label:"flow2",title:"tune.searcher.flow2"},a=void 0,l={unversionedId:"reference/tune/searcher/flow2",id:"reference/tune/searcher/flow2",isDocsHomePage:!1,title:"tune.searcher.flow2",description:"FLOW2 Objects",source:"@site/docs/reference/tune/searcher/flow2.md",sourceDirName:"reference/tune/searcher",slug:"/reference/tune/searcher/flow2",permalink:"/FLAML/docs/reference/tune/searcher/flow2",editUrl:"https://github.com/microsoft/FLAML/edit/main/website/docs/reference/tune/searcher/flow2.md",tags:[],version:"current",frontMatter:{sidebar_label:"flow2",title:"tune.searcher.flow2"},sidebar:"referenceSideBar",previous:{title:"cfo_cat",permalink:"/FLAML/docs/reference/tune/searcher/cfo_cat"},next:{title:"online_searcher",permalink:"/FLAML/docs/reference/tune/searcher/online_searcher"}},c=[{value:"FLOW2 Objects",id:"flow2-objects",children:[{value:"__init__",id:"__init__",children:[],level:4},{value:"complete_config",id:"complete_config",children:[],level:4},{value:"normalize",id:"normalize",children:[],level:4},{value:"denormalize",id:"denormalize",children:[],level:4},{value:"on_trial_complete",id:"on_trial_complete",children:[],level:4},{value:"on_trial_result",id:"on_trial_result",children:[],level:4},{value:"suggest",id:"suggest",children:[],level:4},{value:"can_suggest",id:"can_suggest",children:[],level:4},{value:"config_signature",id:"config_signature",children:[],level:4},{value:"converged",id:"converged",children:[],level:4},{value:"reach",id:"reach",children:[],level:4}],level:2}],s={toc:c};function p(e){let{components:n,...t}=e;return(0,o.yg)("wrapper",(0,r.A)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("h2",{id:"flow2-objects"},"FLOW2 Objects"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"class FLOW2(Searcher)\n")),(0,o.yg)("p",null,"Local search algorithm FLOW2, with adaptive step size."),(0,o.yg)("h4",{id:"__init__"},"_","_","init","_","_"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'def __init__(init_config: dict,\n             metric: Optional[str] = None,\n             mode: Optional[str] = None,\n             space: Optional[dict] = None,\n             resource_attr: Optional[str] = None,\n             min_resource: Optional[float] = None,\n             max_resource: Optional[float] = None,\n             resource_multiple_factor: Optional[float] = None,\n             cost_attr: Optional[str] = "time_total_s",\n             seed: Optional[int] = 20,\n             lexico_objectives=None)\n')),(0,o.yg)("p",null,"Constructor."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Arguments"),":"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"init_config")," - a dictionary of a partial or full initial config,\ne.g., from a subset of controlled dimensions\nto the initial low-cost values.\nE.g., {'epochs': 1}."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"metric")," - A string of the metric name to optimize for."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"mode")," - A string in ","['min', 'max']"," to specify the objective as\nminimization or maximization."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"space")," - A dictionary to specify the search space."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"resource_attr")," - A string to specify the resource dimension and the best\nperformance is assumed to be at the max_resource."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"min_resource")," - A float of the minimal resource to use for the resource_attr."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"max_resource")," - A float of the maximal resource to use for the resource_attr."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"resource_multiple_factor")," - A float of the multiplicative factor\nused for increasing resource."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"cost_attr")," - A string of the attribute used for cost."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"seed")," - An integer of the random seed."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"lexico_objectives")," - dict, default=None | It specifics information needed to perform multi-objective\noptimization with lexicographic preferences. When lexico_objectives is not None, the arguments metric,\nmode will be invalid. This dictionary shall contain the following fields of key-value pairs:",(0,o.yg)("ul",{parentName:"li"},(0,o.yg)("li",{parentName:"ul"},'"metrics":  a list of optimization objectives with the orders reflecting the priorities/preferences of the\nobjectives.'),(0,o.yg)("li",{parentName:"ul"},'"modes" (optional): a list of optimization modes (each mode either "min" or "max") corresponding to the\nobjectives in the metric list. If not provided, we use "min" as the default mode for all the objectives'),(0,o.yg)("li",{parentName:"ul"},'"targets" (optional): a dictionary to specify the optimization targets on the objectives. The keys are the\nmetric names (provided in "metric"), and the values are the numerical target values.'),(0,o.yg)("li",{parentName:"ul"},'"tolerances" (optional): a dictionary to specify the optimality tolerances on objectives. The keys are the metric names (provided in "metrics"), and the values are the absolute/percentage tolerance in the form of numeric/string.\nE.g.,',(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre"},'  ```python\n  lexico_objectives = {\n      "metrics": ["error_rate", "pred_time"],\n      "modes": ["min", "min"],\n      "tolerances": {"error_rate": 0.01, "pred_time": 0.0},\n      "targets": {"error_rate": 0.0},\n  }\n  ```\n')),"We also support percentage tolerance.\nE.g.,",(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre"},'  ```python\n  lexico_objectives = {\n      "metrics": ["error_rate", "pred_time"],\n      "modes": ["min", "min"],\n      "tolerances": {"error_rate": "5%", "pred_time": "0%"},\n      "targets": {"error_rate": 0.0},\n     }\n  ```\n')))))),(0,o.yg)("h4",{id:"complete_config"},"complete","_","config"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"def complete_config(partial_config: Dict,\n                    lower: Optional[Dict] = None,\n                    upper: Optional[Dict] = None) -> Tuple[Dict, Dict]\n")),(0,o.yg)("p",null,"Generate a complete config from the partial config input."),(0,o.yg)("p",null,"Add minimal resource to config if available."),(0,o.yg)("h4",{id:"normalize"},"normalize"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"def normalize(config, recursive=False) -> Dict\n")),(0,o.yg)("p",null,"normalize each dimension in config to ","[0,1]","."),(0,o.yg)("h4",{id:"denormalize"},"denormalize"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"def denormalize(config)\n")),(0,o.yg)("p",null,"denormalize each dimension in config from ","[0,1]","."),(0,o.yg)("h4",{id:"on_trial_complete"},"on","_","trial","_","complete"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"def on_trial_complete(trial_id: str,\n                      result: Optional[Dict] = None,\n                      error: bool = False)\n")),(0,o.yg)("p",null,"Compare with incumbent.\nIf better, move, reset num_complete and num_proposed.\nIf not better and num_complete >= 2*dim, num_allowed += 2."),(0,o.yg)("h4",{id:"on_trial_result"},"on","_","trial","_","result"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"def on_trial_result(trial_id: str, result: Dict)\n")),(0,o.yg)("p",null,"Early update of incumbent."),(0,o.yg)("h4",{id:"suggest"},"suggest"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"def suggest(trial_id: str) -> Optional[Dict]\n")),(0,o.yg)("p",null,"Suggest a new config, one of the following cases:"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"same incumbent, increase resource."),(0,o.yg)("li",{parentName:"ol"},"same resource, move from the incumbent to a random direction."),(0,o.yg)("li",{parentName:"ol"},"same resource, move from the incumbent to the opposite direction.")),(0,o.yg)("h4",{id:"can_suggest"},"can","_","suggest"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef can_suggest() -> bool\n")),(0,o.yg)("p",null,"Can't suggest if 2*dim configs have been proposed for the incumbent\nwhile fewer are completed."),(0,o.yg)("h4",{id:"config_signature"},"config","_","signature"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"def config_signature(config, space: Dict = None) -> tuple\n")),(0,o.yg)("p",null,"Return the signature tuple of a config."),(0,o.yg)("h4",{id:"converged"},"converged"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"@property\ndef converged() -> bool\n")),(0,o.yg)("p",null,"Whether the local search has converged."),(0,o.yg)("h4",{id:"reach"},"reach"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"def reach(other: Searcher) -> bool\n")),(0,o.yg)("p",null,"whether the incumbent can reach the incumbent of other."))}p.isMDXComponent=!0}}]);