"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2615],{5680:(e,r,t)=>{t.d(r,{xA:()=>u,yg:()=>f});var a=t(6540);function n(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function s(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r&&(a=a.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?s(Object(t),!0).forEach((function(r){n(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function i(e,r){if(null==e)return{};var t,a,n=function(e,r){if(null==e)return{};var t,a,n={},s=Object.keys(e);for(a=0;a<s.length;a++)t=s[a],r.indexOf(t)>=0||(n[t]=e[t]);return n}(e,r);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)t=s[a],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var o=a.createContext({}),c=function(e){var r=a.useContext(o),t=r;return e&&(t="function"==typeof e?e(r):l(l({},r),e)),t},u=function(e){var r=c(e.components);return a.createElement(o.Provider,{value:r},e.children)},m={inlineCode:"code",wrapper:function(e){var r=e.children;return a.createElement(a.Fragment,{},r)}},p=a.forwardRef((function(e,r){var t=e.components,n=e.mdxType,s=e.originalType,o=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(t),f=n,d=p["".concat(o,".").concat(f)]||p[f]||m[f]||s;return t?a.createElement(d,l(l({ref:r},u),{},{components:t})):a.createElement(d,l({ref:r},u))}));function f(e,r){var t=arguments,n=r&&r.mdxType;if("string"==typeof e||n){var s=t.length,l=new Array(s);l[0]=p;var i={};for(var o in r)hasOwnProperty.call(r,o)&&(i[o]=r[o]);i.originalType=e,i.mdxType="string"==typeof e?e:n,l[1]=i;for(var c=2;c<s;c++)l[c]=t[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},47:(e,r,t)=>{t.r(r),t.d(r,{contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>o});var a=t(8168),n=(t(6540),t(5680));const s={sidebar_label:"sklearn",title:"automl.time_series.sklearn"},l=void 0,i={unversionedId:"reference/automl/time_series/sklearn",id:"reference/automl/time_series/sklearn",isDocsHomePage:!1,title:"automl.time_series.sklearn",description:"make\\lag\\features",source:"@site/docs/reference/automl/time_series/sklearn.md",sourceDirName:"reference/automl/time_series",slug:"/reference/automl/time_series/sklearn",permalink:"/FLAML/docs/reference/automl/time_series/sklearn",editUrl:"https://github.com/microsoft/FLAML/edit/main/website/docs/reference/automl/time_series/sklearn.md",tags:[],version:"current",frontMatter:{sidebar_label:"sklearn",title:"automl.time_series.sklearn"},sidebar:"referenceSideBar",previous:{title:"time_series_task",permalink:"/FLAML/docs/reference/automl/task/time_series_task"},next:{title:"tcn",permalink:"/FLAML/docs/reference/automl/time_series/tcn"}},o=[{value:"make_lag_features",id:"make_lag_features",children:[],level:4},{value:"Parameters",id:"parameters",children:[],level:2},{value:"Returns",id:"returns",children:[],level:2},{value:"SklearnWrapper Objects",id:"sklearnwrapper-objects",children:[],level:2}],c={toc:o};function u(e){let{components:r,...t}=e;return(0,n.yg)("wrapper",(0,a.A)({},c,t,{components:r,mdxType:"MDXLayout"}),(0,n.yg)("h4",{id:"make_lag_features"},"make","_","lag","_","features"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},"def make_lag_features(X: pd.DataFrame, y: pd.Series, lags: int)\n")),(0,n.yg)("p",null,"Transform input data X, y into autoregressive form by creating ",(0,n.yg)("inlineCode",{parentName:"p"},"lags")," columns."),(0,n.yg)("p",null,"This function is called automatically by FLAML during the training process\nto convert time series data into a format suitable for sklearn-based regression\nmodels (e.g., lgbm, rf, xgboost). Users do NOT need to manually call this function\nor create lagged features themselves."),(0,n.yg)("h2",{id:"parameters"},"Parameters"),(0,n.yg)("p",null,"X : pandas.DataFrame\nInput feature DataFrame, which may contain temporal features and/or exogenous variables."),(0,n.yg)("p",null,"y : array_like, (1d)\nTarget vector (time series values to forecast)."),(0,n.yg)("p",null,"lags : int\nNumber of lagged time steps to use as features."),(0,n.yg)("h2",{id:"returns"},"Returns"),(0,n.yg)("p",null,"pandas.DataFrame\nShifted dataframe with ",(0,n.yg)("inlineCode",{parentName:"p"},"lags")," columns for each original feature.\nThe target variable y is also lagged to prevent data leakage\n(i.e., we use y(t-1), y(t-2), ..., y(t-lags) to predict y(t))."),(0,n.yg)("h2",{id:"sklearnwrapper-objects"},"SklearnWrapper Objects"),(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-python"},"class SklearnWrapper()\n")),(0,n.yg)("p",null,"Wrapper class for using sklearn-based models for time series forecasting."),(0,n.yg)("p",null,"This wrapper automatically handles the transformation of time series data into\na supervised learning format by creating lagged features. It trains separate\nmodels for each step in the forecast horizon."),(0,n.yg)("p",null,"Users typically don't interact with this class directly - it's used internally\nby FLAML when sklearn-based estimators (lgbm, rf, xgboost, etc.) are selected\nfor time series forecasting tasks."))}u.isMDXComponent=!0}}]);