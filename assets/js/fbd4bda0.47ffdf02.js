"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6275],{3905:(e,a,t)=>{t.d(a,{Zo:()=>d,kt:()=>k});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function l(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?l(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function p(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=n.createContext({}),o=function(e){var a=n.useContext(i),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},d=function(e){var a=o(e.components);return n.createElement(i.Provider,{value:a},e.children)},u={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},m=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,l=e.originalType,i=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),m=o(t),k=r,c=m["".concat(i,".").concat(k)]||m[k]||u[k]||l;return t?n.createElement(c,s(s({ref:a},d),{},{components:t})):n.createElement(c,s({ref:a},d))}));function k(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var l=t.length,s=new Array(l);s[0]=m;var p={};for(var i in a)hasOwnProperty.call(a,i)&&(p[i]=a[i]);p.originalType=e,p.mdxType="string"==typeof e?e:r,s[1]=p;for(var o=2;o<l;o++)s[o]=t[o];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2181:(e,a,t)=>{t.r(a),t.d(a,{contentTitle:()=>s,default:()=>d,frontMatter:()=>l,metadata:()=>p,toc:()=>i});var n=t(7462),r=(t(7294),t(3905));const l={sidebar_label:"utils",title:"automl.spark.utils"},s=void 0,p={unversionedId:"reference/automl/spark/utils",id:"reference/automl/spark/utils",isDocsHomePage:!1,title:"automl.spark.utils",description:"to\\pandas\\on\\_spark",source:"@site/docs/reference/automl/spark/utils.md",sourceDirName:"reference/automl/spark",slug:"/reference/automl/spark/utils",permalink:"/FLAML/docs/reference/automl/spark/utils",editUrl:"https://github.com/microsoft/FLAML/edit/main/website/docs/reference/automl/spark/utils.md",tags:[],version:"current",frontMatter:{sidebar_label:"utils",title:"automl.spark.utils"},sidebar:"referenceSideBar",previous:{title:"metrics",permalink:"/FLAML/docs/reference/automl/spark/metrics"},next:{title:"task",permalink:"/FLAML/docs/reference/automl/task/task"}},i=[{value:"to_pandas_on_spark",id:"to_pandas_on_spark",children:[],level:4},{value:"train_test_split_pyspark",id:"train_test_split_pyspark",children:[],level:4},{value:"unique_pandas_on_spark",id:"unique_pandas_on_spark",children:[],level:4},{value:"len_labels",id:"len_labels",children:[],level:4},{value:"unique_value_first_index",id:"unique_value_first_index",children:[],level:4},{value:"iloc_pandas_on_spark",id:"iloc_pandas_on_spark",children:[],level:4},{value:"spark_kFold",id:"spark_kfold",children:[],level:4}],o={toc:i};function d(e){let{components:a,...t}=e;return(0,r.kt)("wrapper",(0,n.Z)({},o,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h4",{id:"to_pandas_on_spark"},"to","_","pandas","_","on","_","spark"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def to_pandas_on_spark(df: Union[DataFrame, sparkDataFrame, Series, psDataFrame, psSeries], index_col: Optional[str] = None, default_index_type: Optional[str] = "distributed-sequence") -> Union[psDataFrame, psSeries]\n')),(0,r.kt)("p",null,"Convert pandas or pyspark dataframe/series to pandas_on_Spark dataframe/series."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"df")," - pandas.DataFrame/series or pyspark dataframe | The input dataframe/series."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"index_col")," - str, optional | The column name to use as index, default None."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"default_index_type"),' - str, optional | The default index type, default "distributed-sequence".')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pyspark.pandas.DataFrame/Series")," - The converted pandas-on-Spark dataframe/series.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import pandas as pd\nfrom flaml.automl.spark.utils import to_pandas_on_spark\n\npdf = DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})\npsdf = to_pandas_on_spark(pdf)\nprint(psdf)\n\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession.builder.getOrCreate()\nsdf = spark.createDataFrame(pdf)\npsdf = to_pandas_on_spark(sdf)\nprint(psdf)\n\npds = Series([1, 2, 3])\npss = to_pandas_on_spark(pds)\nprint(pss)\n')),(0,r.kt)("h4",{id:"train_test_split_pyspark"},"train","_","test","_","split","_","pyspark"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def train_test_split_pyspark(df: Union[sparkDataFrame, psDataFrame], stratify_column: Optional[str] = None, test_fraction: Optional[float] = 0.2, seed: Optional[int] = 1234, to_pandas_spark: Optional[bool] = True, index_col: Optional[str] = "tmp_index_col") -> Tuple[Union[sparkDataFrame, psDataFrame], Union[sparkDataFrame, psDataFrame]]\n')),(0,r.kt)("p",null,"Split a pyspark dataframe into train and test dataframes."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"df")," - pyspark.sql.DataFrame | The input dataframe."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"stratify_column")," - str | The column name to stratify the split. Default None."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"test_fraction")," - float | The fraction of the test data. Default 0.2."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"seed")," - int | The random seed. Default 1234."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"to_pandas_spark")," - bool | Whether to convert the output to pandas_on_spark. Default True."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"index_col")," - str | The column name to use as index. Default None.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  pyspark.sql.DataFrame/pandas_on_spark DataFrame | The train dataframe.\npyspark.sql.DataFrame/pandas_on_spark DataFrame | The test dataframe."),(0,r.kt)("h4",{id:"unique_pandas_on_spark"},"unique","_","pandas","_","on","_","spark"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def unique_pandas_on_spark(psds: Union[psSeries, psDataFrame]) -> Tuple[np.ndarray, np.ndarray]\n")),(0,r.kt)("p",null,"Get the unique values and counts of a pandas_on_spark series."),(0,r.kt)("h4",{id:"len_labels"},"len","_","labels"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def len_labels(y: Union[psSeries, np.ndarray], return_labels=False) -> Union[int, Optional[np.ndarray]]\n")),(0,r.kt)("p",null,"Get the number of unique labels in y."),(0,r.kt)("h4",{id:"unique_value_first_index"},"unique","_","value","_","first","_","index"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def unique_value_first_index(y: Union[Series, psSeries, np.ndarray]) -> Tuple[np.ndarray, np.ndarray]\n")),(0,r.kt)("p",null,"Get the unique values and indices of a pandas series,\npandas_on_spark series or numpy array."),(0,r.kt)("h4",{id:"iloc_pandas_on_spark"},"iloc","_","pandas","_","on","_","spark"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def iloc_pandas_on_spark(psdf: Union[psDataFrame, psSeries, DataFrame, Series], index: Union[int, slice, list], index_col: Optional[str] = "tmp_index_col") -> Union[psDataFrame, psSeries]\n')),(0,r.kt)("p",null,"Get the rows of a pandas_on_spark dataframe/series by index."),(0,r.kt)("h4",{id:"spark_kfold"},"spark","_","kFold"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def spark_kFold(dataset: Union[sparkDataFrame, psDataFrame], nFolds: int = 3, foldCol: str = "", seed: int = 42, index_col: Optional[str] = "tmp_index_col") -> List[Tuple[psDataFrame, psDataFrame]]\n')),(0,r.kt)("p",null,"Generate k-fold splits for a Spark DataFrame.\nAdopted from ",(0,r.kt)("a",{parentName:"p",href:"https://spark.apache.org/docs/latest/api/python/_modules/pyspark/ml/tuning.html#CrossValidator"},"https://spark.apache.org/docs/latest/api/python/_modules/pyspark/ml/tuning.html#CrossValidator")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Arguments"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dataset")," - sparkDataFrame / psDataFrame. | The DataFrame to split."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"nFolds")," - int | The number of folds. Default is 3."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"foldCol"),' - str | The column name to use for fold numbers. If not specified,\nthe DataFrame will be randomly split. Default is "".\nThe same group will not appear in two different folds (the number of\ndistinct groups has to be at least equal to the number of folds).\nThe folds are approximately balanced in the sense that the number of\ndistinct groups is approximately the same in each fold.'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"seed")," - int | The random seed. Default is 42."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"index_col"),' - str | The name of the index column. Default is "tmp_index_col".')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("p",null,"  A list of (train, validation) DataFrames."))}d.isMDXComponent=!0}}]);