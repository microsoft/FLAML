"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7399],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||i;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3078:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const i={},o="Tune User Defined Function",s={unversionedId:"Use-Cases/Tune-User-Defined-Function",id:"Use-Cases/Tune-User-Defined-Function",isDocsHomePage:!1,title:"Tune User Defined Function",description:"flaml.tune is a module for economical hyperparameter tuning. It is used internally by flaml.AutoML. It can also be used to directly tune a user-defined function (UDF), which is not limited to machine learning model training. You can use flaml.tune instead of flaml.AutoML if one of the following is true:",source:"@site/docs/Use-Cases/Tune-User-Defined-Function.md",sourceDirName:"Use-Cases",slug:"/Use-Cases/Tune-User-Defined-Function",permalink:"/FLAML/docs/Use-Cases/Tune-User-Defined-Function",editUrl:"https://github.com/microsoft/FLAML/edit/main/website/docs/Use-Cases/Tune-User-Defined-Function.md",tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Task Oriented AutoML",permalink:"/FLAML/docs/Use-Cases/Task-Oriented-AutoML"},next:{title:"Zero Shot AutoML",permalink:"/FLAML/docs/Use-Cases/Zero-Shot-AutoML"}},l=[{value:"Basic Tuning Procedure",id:"basic-tuning-procedure",children:[{value:"Tuning objective",id:"tuning-objective",children:[],level:3},{value:"Search space",id:"search-space",children:[{value:"<strong>Details and guidelines on hyperparameter search space</strong>",id:"details-and-guidelines-on-hyperparameter-search-space",children:[],level:4},{value:"Cost-related hyperparameters",id:"cost-related-hyperparameters",children:[],level:4}],level:3},{value:"Tuning constraints",id:"tuning-constraints",children:[],level:3},{value:"Put together",id:"put-together",children:[],level:3},{value:"Result analysis",id:"result-analysis",children:[],level:3}],level:2},{value:"Advanced Tuning Options",id:"advanced-tuning-options",children:[{value:"More constraints on the tuning",id:"more-constraints-on-the-tuning",children:[],level:3},{value:"Parallel tuning",id:"parallel-tuning",children:[],level:3},{value:"Trial scheduling",id:"trial-scheduling",children:[{value:"1. An authentic scheduler implemented in FLAML (<code>scheduler=&#39;flaml&#39;</code>).",id:"1-an-authentic-scheduler-implemented-in-flaml-schedulerflaml",children:[],level:4},{value:"2. A scheduler of the  TrialScheduler class from <code>ray.tune</code>.",id:"2-a-scheduler-of-the--trialscheduler-class-from-raytune",children:[],level:4}],level:3},{value:"Warm start",id:"warm-start",children:[],level:3},{value:"Reproducibility",id:"reproducibility",children:[],level:3}],level:2},{value:"Hyperparameter Optimization Algorithm",id:"hyperparameter-optimization-algorithm",children:[{value:"CFO: Frugal Optimization for Cost-related Hyperparameters",id:"cfo-frugal-optimization-for-cost-related-hyperparameters",children:[],level:3},{value:"BlendSearch: Economical Hyperparameter Optimization With Blended Search Strategy",id:"blendsearch-economical-hyperparameter-optimization-with-blended-search-strategy",children:[],level:3}],level:2}],p={toc:l};function c(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"tune-user-defined-function"},"Tune User Defined Function"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"../reference/tune/tune"},(0,r.kt)("inlineCode",{parentName:"a"},"flaml.tune"))," is a module for economical hyperparameter tuning. It is used internally by ",(0,r.kt)("inlineCode",{parentName:"p"},"flaml.AutoML"),". It can also be used to directly tune a user-defined function (UDF), which is not limited to machine learning model training. You can use ",(0,r.kt)("inlineCode",{parentName:"p"},"flaml.tune")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"flaml.AutoML")," if one of the following is true:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Your machine learning task is not one of the built-in tasks from ",(0,r.kt)("inlineCode",{parentName:"li"},"flaml.AutoML"),"."),(0,r.kt)("li",{parentName:"ol"},"Your input cannot be represented as X_train + y_train or dataframe + label."),(0,r.kt)("li",{parentName:"ol"},"The optimization metric is not measurable via validation data only. For example, when you want to directly optimize a downstream application instead of a model accuracy metric."),(0,r.kt)("li",{parentName:"ol"},"You need to tune a function that may not even be a machine learning procedure.")),(0,r.kt)("h2",{id:"basic-tuning-procedure"},"Basic Tuning Procedure"),(0,r.kt)("p",null,"There are three essential steps (assuming the knowledge of the set of hyperparameters to tune) to use ",(0,r.kt)("inlineCode",{parentName:"p"},"flaml.tune")," to finish a basic tuning task:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Specify the ",(0,r.kt)("a",{parentName:"li",href:"#tuning-objective"},"tuning objective")," with respect to the hyperparameters."),(0,r.kt)("li",{parentName:"ol"},"Specify a ",(0,r.kt)("a",{parentName:"li",href:"#search-space"},"search space")," of the hyperparameters."),(0,r.kt)("li",{parentName:"ol"},"Specify ",(0,r.kt)("a",{parentName:"li",href:"#tuning-constraints"},"tuning constraints"),", including constraints on the resource budget to do the tuning, constraints on the configurations, or/and constraints on a (or multiple) particular metric(s).")),(0,r.kt)("p",null,"With these steps, you can ",(0,r.kt)("a",{parentName:"p",href:"#put-together"},"perform a basic tuning task")," accordingly."),(0,r.kt)("h3",{id:"tuning-objective"},"Tuning objective"),(0,r.kt)("p",null,"Related arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"evaluation_function"),": A user-defined evaluation function."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"metric"),": A string of the metric name to optimize for."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mode"),":  A string in ","['min', 'max']"," to specify the objective as minimization or maximization.")),(0,r.kt)("p",null,"The first step is to specify your tuning objective.\nTo do it, you should first specify your evaluation procedure (e.g., perform a machine learning model training and validation) with respect to the hyperparameters in a user-defined function ",(0,r.kt)("inlineCode",{parentName:"p"},"evaluation_function"),".\nThe function requires a hyperparameter configuration as input, and can simply return a metric value in a scalar or return a dictionary of metric name and metric value pairs."),(0,r.kt)("p",null,"In the following code, we define an evaluation function with respect to two hyperparameters named ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," according to ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"o"),(0,r.kt)("mi",{parentName:"mrow"},"b"),(0,r.kt)("mi",{parentName:"mrow"},"j"),(0,r.kt)("mo",{parentName:"mrow"},":"),(0,r.kt)("mo",{parentName:"mrow"},"="),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"x"),(0,r.kt)("mo",{parentName:"mrow"},"\u2212"),(0,r.kt)("mn",{parentName:"mrow"},"85000"),(0,r.kt)("msup",{parentName:"mrow"},(0,r.kt)("mo",{parentName:"msup",stretchy:"false"},")"),(0,r.kt)("mn",{parentName:"msup"},"2")),(0,r.kt)("mo",{parentName:"mrow"},"\u2212"),(0,r.kt)("mi",{parentName:"mrow"},"x"),(0,r.kt)("mi",{parentName:"mrow",mathvariant:"normal"},"/"),(0,r.kt)("mi",{parentName:"mrow"},"y")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"obj := (x-85000)^2 - x/y")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8888799999999999em",verticalAlign:"-0.19444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"o"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"b"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05724em"}},"j"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},":")),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.36687em",verticalAlign:"0em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"="),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2777777777777778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,r.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1.064108em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"8"),(0,r.kt)("span",{parentName:"span",className:"mord"},"5"),(0,r.kt)("span",{parentName:"span",className:"mord"},"0"),(0,r.kt)("span",{parentName:"span",className:"mord"},"0"),(0,r.kt)("span",{parentName:"span",className:"mord"},"0"),(0,r.kt)("span",{parentName:"span",className:"mclose"},(0,r.kt)("span",{parentName:"span",className:"mclose"},")"),(0,r.kt)("span",{parentName:"span",className:"msupsub"},(0,r.kt)("span",{parentName:"span",className:"vlist-t"},(0,r.kt)("span",{parentName:"span",className:"vlist-r"},(0,r.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8141079999999999em"}},(0,r.kt)("span",{parentName:"span",style:{top:"-3.063em",marginRight:"0.05em"}},(0,r.kt)("span",{parentName:"span",className:"pstrut",style:{height:"2.7em"}}),(0,r.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,r.kt)("span",{parentName:"span",className:"mord mtight"},"2")))))))),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,r.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"x"),(0,r.kt)("span",{parentName:"span",className:"mord"},"/"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"y"))))),". Note that we use this toy example here for more accessible demonstration purposes. In real use cases, the evaluation function usually cannot be written in this closed form, but instead involves a black-box and expensive evaluation procedure.  Please check out ",(0,r.kt)("a",{parentName:"p",href:"../Examples/Tune-HuggingFace"},"Tune HuggingFace"),", ",(0,r.kt)("a",{parentName:"p",href:"../Examples/Tune-PyTorch"},"Tune PyTorch")," and ",(0,r.kt)("a",{parentName:"p",href:"../Getting-Started#tune-user-defined-function"},"Tune LightGBM")," for real examples of tuning tasks."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import time\n\ndef evaluate_config(config: dict):\n    """evaluate a hyperparameter configuration"""\n    score = (config["x"] - 85000) ** 2 - config["x"] / config["y"]\n    # usually the evaluation takes an non-neglible cost\n    # and the cost could be related to certain hyperparameters\n    # here we simulate this cost by calling the time.sleep() function\n    # here we assume the cost is proportional to x\n    faked_evaluation_cost = config["x"] / 100000\n    time.sleep(faked_evaluation_cost)\n    # we can return a single float as a score on the input config:\n    # return score\n    # or, we can return a dictionary that maps metric name to metric value:\n    return {"score": score, "evaluation_cost": faked_evaluation_cost, "constraint_metric": config["x"] * config["y"]}\n')),(0,r.kt)("p",null,"When the evaluation function returns a dictionary of metrics, you need to specify the name of the metric to optimize via the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"metric")," (this can be skipped when the function is just returning a scalar). In addition, you need to specify a mode of your optimization/tuning task (maximization or minimization) via the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"mode"),' by choosing from "min" or "max".'),(0,r.kt)("p",null,"For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'flaml.tune.run(evaluation_function=evaluate_config, metric="score", mode="min", ...)\n')),(0,r.kt)("h3",{id:"search-space"},"Search space"),(0,r.kt)("p",null,"Related arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"config"),": A dictionary to specify the search space."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"low_cost_partial_config")," (optional): A dictionary from a subset of controlled dimensions to the initial low-cost values."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cat_hp_cost")," (optional): A dictionary from a subset of categorical dimensions to the relative cost of each choice.")),(0,r.kt)("p",null,"The second step is to specify a search space of the hyperparameters through the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"config"),". In the search space, you need to specify valid values for your hyperparameters and can specify how these values are sampled (e.g., from a uniform distribution or a log-uniform distribution)."),(0,r.kt)("p",null,"In the following code example, we include a search space for the two hyperparameters ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," as introduced above. The valid values for both are integers in the range of ","[1, 100000]",". The values for ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," are sampled uniformly in the specified range (using ",(0,r.kt)("inlineCode",{parentName:"p"},"tune.randint(lower=1, upper=100000)"),"), and the values for ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," are sampled uniformly in logarithmic space of the specified range (using ",(0,r.kt)("inlineCode",{parentName:"p"},"tune.lograndit(lower=1, upper=100000)"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from flaml import tune\n\n# construct a search space for the hyperparameters x and y.\nconfig_search_space = {\n    "x": tune.lograndint(lower=1, upper=100000),\n    "y": tune.randint(lower=1, upper=100000)\n}\n\n# provide the search space to tune.run\ntune.run(..., config=config_search_space, ...)\n')),(0,r.kt)("h4",{id:"details-and-guidelines-on-hyperparameter-search-space"},(0,r.kt)("strong",{parentName:"h4"},"Details and guidelines on hyperparameter search space")),(0,r.kt)("p",null,"The corresponding value of a particular hyperparameter in the search space dictionary is called a ",(0,r.kt)("em",{parentName:"p"},"domain"),", for example, ",(0,r.kt)("inlineCode",{parentName:"p"},"tune.randint(lower=1, upper=100000)")," is the domain for the hyperparameter ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),".\nThe domain specifies a ",(0,r.kt)("em",{parentName:"p"},"type")," and ",(0,r.kt)("em",{parentName:"p"},"valid range")," to sample parameters from. Supported types include float, integer, and categorical."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Categorical hyperparameter")),(0,r.kt)("p",{parentName:"li"},"If it is a categorical hyperparameter, then you should use ",(0,r.kt)("inlineCode",{parentName:"p"},"tune.choice(possible_choices)")," in which ",(0,r.kt)("inlineCode",{parentName:"p"},"possible_choices"),' is the list of possible categorical values of the hyperparameter. For example, if you are tuning the optimizer used in model training, and the candidate optimizers are "sgd" and "adam", you should specify the search space in the following way:'))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'{\n    "optimizer": tune.choice(["sgd", "adam"]),\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Numerical hyperparameter"))),(0,r.kt)("p",null,"If it is a numerical hyperparameter, you need to know whether it takes integer values or float values. In addition, you need to know:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The range of valid values, i.e., what are the lower limit and upper limit of the hyperparameter value?"),(0,r.kt)("li",{parentName:"ul"},"Do you want to sample in linear scale or log scale? It is a common practice to sample in the log scale if the valid value range is large and the evaluation function changes more regularly with respect to the log domain, as shown in the following example for learning rate tuning. In this code example, we set the lower limit and the upper limit of the learning rate to be 1/1024 and 1.0, respectively. We sample in the log space because model performance changes more regularly in the log scale with respect to the learning rate within such a large search range.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'{\n"learning_rate": tune.loguniform(lower=1 / 1024, upper=1.0),\n}\n')),(0,r.kt)("p",null,"When the search range of learning rate is small, it is more common to sample in the linear scale as shown in the following example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'{\n"learning_rate": tune.uniform(lower=0.1, upper=0.2),\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Do you have quantization granularity requirements?")),(0,r.kt)("p",null,"When you have a desired quantization granularity for the hyperparameter change, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"tune.qlograndint")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"tune.qloguniform")," to realize the quantization requirement. The following code example helps you realize the need for sampling uniformly in the range of 0.1 and 0.2 with increments of 0.02, i.e., the sampled learning rate can only take values in {0.1, 0.12, 0.14, 0.16, ..., 0.2},"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'{\n"learning_rate": tune.uniform(lower=0.1, upper=0.2, q=0.02),\n}\n')),(0,r.kt)("p",null,"You can find the corresponding search space choice in the table below once you have answers to the aforementioned three questions."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null}),(0,r.kt)("th",{parentName:"tr",align:null},"Integer"),(0,r.kt)("th",{parentName:"tr",align:null},"Float"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"linear scale"),(0,r.kt)("td",{parentName:"tr",align:null},"tune.randint(lower: int, upper: int)"),(0,r.kt)("td",{parentName:"tr",align:null},"tune.uniform(lower: float, upper: float)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"log scale"),(0,r.kt)("td",{parentName:"tr",align:null},"tune.lograndint(lower: int, upper: int, base: float = 10"),(0,r.kt)("td",{parentName:"tr",align:null},"tune.loguniform(lower: float, upper: float, base: float = 10)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"linear scale with quantization"),(0,r.kt)("td",{parentName:"tr",align:null},"tune.qrandint(lower: int, upper: int, q: int = 1)"),(0,r.kt)("td",{parentName:"tr",align:null},"tune.quniform(lower: float, upper: float, q: float = 1)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"log scale with quantization"),(0,r.kt)("td",{parentName:"tr",align:null},"tune.qlograndint(lower: int, upper, q: int = 1, base: float = 10)"),(0,r.kt)("td",{parentName:"tr",align:null},"tune.qloguniform(lower: float, upper, q: float = 1, base: float = 10)")))),(0,r.kt)("p",null,"|"),(0,r.kt)("p",null,"See the example below for the commonly used types of domains."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'config = {\n    # Sample a float uniformly between -5.0 and -1.0\n    "uniform": tune.uniform(-5, -1),\n\n    # Sample a float uniformly between 3.2 and 5.4,\n    # rounding to increments of 0.2\n    "quniform": tune.quniform(3.2, 5.4, 0.2),\n\n    # Sample a float uniformly between 0.0001 and 0.01, while\n    # sampling in log space\n    "loguniform": tune.loguniform(1e-4, 1e-2),\n\n    # Sample a float uniformly between 0.0001 and 0.1, while\n    # sampling in log space and rounding to increments of 0.00005\n    "qloguniform": tune.qloguniform(1e-4, 1e-1, 5e-5),\n\n    # Sample a random float from a normal distribution with\n    # mean=10 and sd=2\n    "randn": tune.randn(10, 2),\n\n    # Sample a random float from a normal distribution with\n    # mean=10 and sd=2, rounding to increments of 0.2\n    "qrandn": tune.qrandn(10, 2, 0.2),\n\n    # Sample a integer uniformly between -9 (inclusive) and 15 (exclusive)\n    "randint": tune.randint(-9, 15),\n\n    # Sample a random uniformly between -21 (inclusive) and 12 (inclusive (!))\n    # rounding to increments of 3 (includes 12)\n    "qrandint": tune.qrandint(-21, 12, 3),\n\n    # Sample a integer uniformly between 1 (inclusive) and 10 (exclusive),\n    # while sampling in log space\n    "lograndint": tune.lograndint(1, 10),\n\n    # Sample a integer uniformly between 2 (inclusive) and 10 (inclusive (!)),\n    # while sampling in log space and rounding to increments of 2\n    "qlograndint": tune.qlograndint(2, 10, 2),\n\n    # Sample an option uniformly from the specified choices\n    "choice": tune.choice(["a", "b", "c"]),\n}\n')),(0,r.kt)("h4",{id:"cost-related-hyperparameters"},"Cost-related hyperparameters"),(0,r.kt)("p",null,"Cost-related hyperparameters are a subset of the hyperparameters which directly affect the computation cost incurred in the evaluation of any hyperparameter configuration. For example, the number of estimators (",(0,r.kt)("inlineCode",{parentName:"p"},"n_estimators"),") and the maximum number of leaves (",(0,r.kt)("inlineCode",{parentName:"p"},"max_leaves"),") are known to affect the training cost of tree-based learners. So they are cost-related hyperparameters for tree-based learners."),(0,r.kt)("p",null,"When cost-related hyperparameters exist, the evaluation cost in the search space is heterogeneous.\nIn this case, designing a search space with proper ranges of the hyperparameter values is highly non-trivial. Classical tuning algorithms such as Bayesian optimization and random search are typically sensitive to such ranges.  It may take them a very high cost to find a good choice if the ranges are too large. And if the ranges are too small, the optimal choice(s) may not be included and thus not possible to be found. With our method, you can use a search space with larger ranges in the case of heterogeneous cost."),(0,r.kt)("p",null,"Our search algorithms are designed to finish the tuning process at a low total cost when the evaluation cost in the search space is heterogeneous.\nSo in such scenarios, if you are aware of low-cost configurations for the cost-related hyperparameters, you are encouraged to set them as the ",(0,r.kt)("inlineCode",{parentName:"p"},"low_cost_partial_config"),", which is a dictionary of a subset of the hyperparameter coordinates whose value corresponds to a configuration with known low cost.  Using the example of the tree-based methods again, since we know that small ",(0,r.kt)("inlineCode",{parentName:"p"},"n_estimators")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"max_leaves")," generally correspond to simpler models and thus lower cost, we set ",(0,r.kt)("inlineCode",{parentName:"p"},"{'n_estimators': 4, 'max_leaves': 4}")," as the ",(0,r.kt)("inlineCode",{parentName:"p"},"low_cost_partial_config")," by default (note that 4 is the lower bound of search space for these two hyperparameters), e.g., in LGBM. Please find more details on how the algorithm works ",(0,r.kt)("a",{parentName:"p",href:"#cfo-frugal-optimization-for-cost-related-hyperparameters"},"here"),"."),(0,r.kt)("p",null,"In addition, if you are aware of the cost relationship between different categorical hyperparameter choices, you are encouraged to provide this information through ",(0,r.kt)("inlineCode",{parentName:"p"},"cat_hp_cost"),". It also helps the search algorithm to reduce the total cost."),(0,r.kt)("h3",{id:"tuning-constraints"},"Tuning constraints"),(0,r.kt)("p",null,"Related arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"time_budget_s"),": The time budget in seconds."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"num_samples"),": An integer of the number of configs to try."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"config_constraints")," (optional): A list of config constraints to be satisfied."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"metric_constraints")," (optional): A list of metric constraints to be satisfied. e.g., ",(0,r.kt)("inlineCode",{parentName:"li"},"['precision', '>=', 0.9]"),".")),(0,r.kt)("p",null,"The third step is to specify constraints of the tuning task. One notable property of ",(0,r.kt)("inlineCode",{parentName:"p"},"flaml.tune")," is that it is able to finish the tuning process (obtaining good results) within a required resource constraint. A user can either provide the resource constraint in terms of wall-clock time (in seconds) through the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"time_budget_s"),", or in terms of the number of trials through the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"num_samples"),".  The following example shows three use cases:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# Set a resource constraint of 60 seconds wall-clock time for the tuning.\nflaml.tune.run(..., time_budget_s=60, ...)\n\n# Set a resource constraint of 100 trials for the tuning.\nflaml.tune.run(..., num_samples=100, ...)\n\n# Use at most 60 seconds and at most 100 trials for the tuning.\nflaml.tune.run(..., time_budget_s=60, num_samples=100, ...)\n")),(0,r.kt)("p",null,"Optionally, you can provide a list of config constraints to be satisfied through the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"config_constraints")," and provide a list of metric constraints to be satisfied through the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"metric_constraints"),". We provide more details about related use cases in the ",(0,r.kt)("a",{parentName:"p",href:"#more-constraints-on-the-tuning"},"Advanced Tuning Options")," section."),(0,r.kt)("h3",{id:"put-together"},"Put together"),(0,r.kt)("p",null,"After the aforementioned key steps, one is ready to perform a tuning task by calling ",(0,r.kt)("a",{parentName:"p",href:"../reference/tune/tune#run"},(0,r.kt)("inlineCode",{parentName:"a"},"flaml.tune.run()")),". Below is a quick sequential tuning example using the pre-defined search space ",(0,r.kt)("inlineCode",{parentName:"p"},"config_search_space")," and a minimization (",(0,r.kt)("inlineCode",{parentName:"p"},"mode='min'"),") objective for the ",(0,r.kt)("inlineCode",{parentName:"p"},"score")," metric evaluated in ",(0,r.kt)("inlineCode",{parentName:"p"},"evaluate_config"),", using the default serach algorithm in flaml. The time budget is 10 seconds (",(0,r.kt)("inlineCode",{parentName:"p"},"time_budget_s=10"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# require: pip install flaml[blendsearch]\nanalysis = tune.run(\n    evaluate_config,  # the function to evaluate a config\n    config=config_search_space,  # the search space defined\n    metric="score",\n    mode="min",  # the optimization mode, "min" or "max"\n    num_samples=-1,  # the maximal number of configs to try, -1 means infinite\n    time_budget_s=10,  # the time budget in seconds\n)\n')),(0,r.kt)("h3",{id:"result-analysis"},"Result analysis"),(0,r.kt)("p",null,"Once the tuning process finishes, it returns an ",(0,r.kt)("a",{parentName:"p",href:"../reference/tune/analysis"},"ExperimentAnalysis")," object, which provides methods to analyze the tuning."),(0,r.kt)("p",null,"In the following code example, we retrieve the best configuration found during the tuning, and retrieve the best trial's result from the returned ",(0,r.kt)("inlineCode",{parentName:"p"},"analysis"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'analysis = tune.run(\n    evaluate_config,  # the function to evaluate a config\n    config=config_search_space,  # the search space defined\n    metric="score",\n    mode="min",  # the optimization mode, "min" or "max"\n    num_samples=-1,  # the maximal number of configs to try, -1 means infinite\n    time_budget_s=10,  # the time budget in seconds\n)\nprint(analysis.best_config)  # the best config\nprint(analysis.best_trial.last_result)  # the best trial\'s result\n')),(0,r.kt)("h2",{id:"advanced-tuning-options"},"Advanced Tuning Options"),(0,r.kt)("p",null,"There are several advanced tuning options worth mentioning."),(0,r.kt)("h3",{id:"more-constraints-on-the-tuning"},"More constraints on the tuning"),(0,r.kt)("p",null,"A user can specify constraints on the configurations to be satisfied via the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"config_constraints"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"config_constraints"),' receives a list of such constraints to be satisfied. Specifically, each constraint is a tuple that consists of (1) a function that takes a configuration as input and returns a numerical value; (2) an operation chosen from "<=", ">=", "<" or ">"; (3) a numerical threshold.'),(0,r.kt)("p",null,"In the following code example, we constrain the output of ",(0,r.kt)("inlineCode",{parentName:"p"},"area"),", which takes a configuration as input and outputs a numerical value, to be no larger than 1000."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def area(config):\n    return config["width"] * config["height"]\n\nflaml.tune.run(evaluation_function=evaluate_config, mode="min",\n               config=config_search_space,\n               config_constraints=[(area, "<=", 1000)], ...)\n')),(0,r.kt)("p",null," You can also specify a list of metric constraints to be satisfied via the argument ",(0,r.kt)("inlineCode",{parentName:"p"},"metric_constraints"),". Each element in the ",(0,r.kt)("inlineCode",{parentName:"p"},"metric_constraints")," list is a tuple that consists of (1) a string specifying the name of the metric (the metric name must be defined and returned in the user-defined ",(0,r.kt)("inlineCode",{parentName:"p"},"evaluation_function"),'); (2) an operation chosen from "<=" or ">="; (3) a numerical threshold.'),(0,r.kt)("p",null," In the following code example, we constrain the metric ",(0,r.kt)("inlineCode",{parentName:"p"},"score")," to be no larger than 0.4."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'flaml.tune.run(evaluation_function=evaluate_config, mode="min",\n               config=config_search_space,\n               metric_constraints=[("score", "<=", 0.4)],...)\n')),(0,r.kt)("h3",{id:"parallel-tuning"},"Parallel tuning"),(0,r.kt)("p",null,"Related arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"use_ray"),": A boolean of whether to use ray as the backend."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"resources_per_trial"),": A dictionary of the hardware resources to allocate per trial, e.g., ",(0,r.kt)("inlineCode",{parentName:"li"},"{'cpu': 1}"),". Only valid when using ray backend.")),(0,r.kt)("p",null,"You can perform parallel tuning by specifying ",(0,r.kt)("inlineCode",{parentName:"p"},"use_ray=True")," (requiring flaml","[ray]"," option installed). You can also limit the amount of resources allocated per trial by specifying ",(0,r.kt)("inlineCode",{parentName:"p"},"resources_per_trial"),", e.g., ",(0,r.kt)("inlineCode",{parentName:"p"},"resources_per_trial={'cpu': 2}"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# require: pip install flaml[ray]\nanalysis = tune.run(\n    evaluate_config,  # the function to evaluate a config\n    config=config_search_space,  # the search space defined\n    metric="score",\n    mode="min",  # the optimization mode, "min" or "max"\n    num_samples=-1,  # the maximal number of configs to try, -1 means infinite\n    time_budget_s=10,  # the time budget in seconds\n    use_ray=True,\n    resources_per_trial={"cpu": 2}  # limit resources allocated per trial\n)\nprint(analysis.best_trial.last_result)  # the best trial\'s result\nprint(analysis.best_config)  # the best config\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"A headsup about computation overhead.")," When parallel tuning is used, there will be a certain amount of computation overhead in each trial. In case each trial's original cost is much smaller than the overhead, parallel tuning can underperform sequential tuning. Sequential tuning is recommended when compute resource is limited, and each trial can consume all the resources."),(0,r.kt)("h3",{id:"trial-scheduling"},"Trial scheduling"),(0,r.kt)("p",null,"Related arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"scheduler"),": A scheduler for executing the trials."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"resource_attr"),": A string to specify the resource dimension used by the scheduler."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"min_resource"),": A float of the minimal resource to use for the resource_attr."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"max_resource"),": A float of the maximal resource to use for the resource_attr."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"reduction_factor"),": A float of the reduction factor used for incremental pruning.")),(0,r.kt)("p",null,"A scheduler can help manage the trials' execution. It can be used to perform multi-fiedlity evalution, or/and early stopping. You can use two different types of schedulers in ",(0,r.kt)("inlineCode",{parentName:"p"},"flaml.tune")," via ",(0,r.kt)("inlineCode",{parentName:"p"},"scheduler"),"."),(0,r.kt)("h4",{id:"1-an-authentic-scheduler-implemented-in-flaml-schedulerflaml"},"1. An authentic scheduler implemented in FLAML (",(0,r.kt)("inlineCode",{parentName:"h4"},"scheduler='flaml'"),")."),(0,r.kt)("p",null,"This scheduler is authentic to the new search algorithms provided by FLAML. In a nutshell, it starts the search with the minimum resource. It switches between HPO with the current resource and increasing the resource for evaluation depending on which leads to faster improvement."),(0,r.kt)("p",null,"If this scheduler is used, you need to"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Specify a resource dimension. Conceptually a 'resource dimension' is a factor that affects the cost of the evaluation (e.g., sample size, the number of epochs). You need to specify the name of the resource dimension via ",(0,r.kt)("inlineCode",{parentName:"p"},"resource_attr"),". For example, if ",(0,r.kt)("inlineCode",{parentName:"p"},'resource_attr="sample_size"'),", then the config dict passed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"evaluation_function"),' would contain a key "sample_size" and its value suggested by the search algorithm. That value should be used in the evaluation function to control the compute cost. The larger is the value, the more expensive the evaluation is.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Provide the lower and upper limit of the resource dimension via ",(0,r.kt)("inlineCode",{parentName:"p"},"min_resource")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"max_resource"),", and optionally provide ",(0,r.kt)("inlineCode",{parentName:"p"},"reduction_factor"),", which determines the magnitude of resource (multiplicative) increase when we decide to increase the resource."))),(0,r.kt)("p",null,"In the following code example, we consider the sample size as the resource dimension. It determines how much data is used to perform training as reflected in the ",(0,r.kt)("inlineCode",{parentName:"p"},"evaluation_function"),". We set the ",(0,r.kt)("inlineCode",{parentName:"p"},"min_resource")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"max_resource")," to 1000 and the size of the full training dataset, respectively."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from flaml import tune\nfrom functools import partial\nfrom flaml.data import load_openml_task\n\ndef obj_from_resource_attr(resource_attr, X_train, X_test, y_train, y_test, config):\n    from lightgbm import LGBMClassifier\n    from sklearn.metrics import accuracy_score\n\n    # in this example sample size is our resource dimension\n    resource = int(config[resource_attr])\n    sampled_X_train = X_train.iloc[:resource]\n    sampled_y_train = y_train[:resource]\n\n    # construct a LGBM model from the config\n    # note that you need to first remove the resource_attr field\n    # from the config as it is not part of the original search space\n    model_config = config.copy()\n    del model_config[resource_attr]\n    model = LGBMClassifier(**model_config)\n\n    model.fit(sampled_X_train, sampled_y_train)\n    y_test_predict = model.predict(X_test)\n    test_loss = 1.0 - accuracy_score(y_test, y_test_predict)\n    return {resource_attr: resource, "loss": test_loss}\n\nX_train, X_test, y_train, y_test = load_openml_task(task_id=7592, data_dir="test/")\nmax_resource = len(y_train)\nresource_attr = "sample_size"\nmin_resource = 1000\nanalysis = tune.run(\n    partial(obj_from_resource_attr, resource_attr, X_train, X_test, y_train, y_test),\n    config = {\n        "n_estimators": tune.lograndint(lower=4, upper=32768),\n        "max_leaves": tune.lograndint(lower=4, upper=32768),\n        "learning_rate": tune.loguniform(lower=1 / 1024, upper=1.0),\n    },\n    metric="loss",\n    mode="min",\n    resource_attr=resource_attr,\n    scheduler="flaml",\n    max_resource=max_resource,\n    min_resource=min_resource,\n    reduction_factor=2,\n    time_budget_s=10,\n    num_samples=-1,\n)\n')),(0,r.kt)("p",null,"You can find more details about this scheduler in ",(0,r.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/1911.04706.pdf"},"this paper"),"."),(0,r.kt)("h4",{id:"2-a-scheduler-of-the--trialscheduler-class-from-raytune"},"2. A scheduler of the  ",(0,r.kt)("a",{parentName:"h4",href:"https://docs.ray.io/en/latest/tune/api_docs/schedulers.html#tune-schedulers"},(0,r.kt)("inlineCode",{parentName:"a"},"TrialScheduler"))," class from ",(0,r.kt)("inlineCode",{parentName:"h4"},"ray.tune"),"."),(0,r.kt)("p",null,"There is a handful of schedulers of this type implemented in ",(0,r.kt)("inlineCode",{parentName:"p"},"ray.tune"),", for example, ",(0,r.kt)("a",{parentName:"p",href:"https://docs.ray.io/en/latest/tune/api_docs/schedulers.html#asha-tune-schedulers-ashascheduler"},"ASHA"),", ",(0,r.kt)("a",{parentName:"p",href:"https://docs.ray.io/en/latest/tune/api_docs/schedulers.html#tune-original-hyperband"},"HyperBand"),", ",(0,r.kt)("a",{parentName:"p",href:"https://docs.ray.io/en/latest/tune/api_docs/schedulers.html#tune-scheduler-bohb"},"BOHB"),", etc."),(0,r.kt)("p",null,"To use this type of scheduler you can either (1) set ",(0,r.kt)("inlineCode",{parentName:"p"},"scheduler='asha'"),", which will automatically create an  ",(0,r.kt)("a",{parentName:"p",href:"https://docs.ray.io/en/latest/tune/api_docs/schedulers.html#asha-tune-schedulers-ashascheduler"},"ASHAScheduler")," instance using the provided inputs (",(0,r.kt)("inlineCode",{parentName:"p"},"resource_attr"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"min_resource"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"max_resource"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"reduction_factor"),"); or (2) create an instance by yourself and provided it via ",(0,r.kt)("inlineCode",{parentName:"p"},"scheduler"),", as shown in the following code example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'#  require: pip install flaml[ray]\nfrom ray.tune.schedulers import HyperBandScheduler\nmy_scheduler = HyperBandScheduler(time_attr="sample_size", max_t=max_resource, reduction_factor=2)\ntune.run(.., scheduler=my_scheduler, ...)\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Similar to the case where the ",(0,r.kt)("inlineCode",{parentName:"p"},"flaml")," scheduler is used, you need to specify the resource dimension, use the resource dimension accordingly in your ",(0,r.kt)("inlineCode",{parentName:"p"},"evaluation_function"),", and provide the necessary information needed for scheduling, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"min_resource"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"max_resource")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"reduction_factor")," (depending on the requirements of the specific scheduler).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Different from the case when the ",(0,r.kt)("inlineCode",{parentName:"p"},"flaml")," scheduler is used, the amount of resources to use at each iteration is not suggested by the search algorithm through the ",(0,r.kt)("inlineCode",{parentName:"p"},"resource_attr")," in a configuration. You need to specify the evaluation schedule explicitly by yourself in the ",(0,r.kt)("inlineCode",{parentName:"p"},"evaluation_function")," and ",(0,r.kt)("strong",{parentName:"p"},"report intermediate results (using ",(0,r.kt)("inlineCode",{parentName:"strong"},"tune.report()"),") accordingly"),". In the following code example, we use the ASHA scheduler by setting ",(0,r.kt)("inlineCode",{parentName:"p"},'scheduler="asha"'),". We specify ",(0,r.kt)("inlineCode",{parentName:"p"},"resource_attr"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"min_resource"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"min_resource")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"reduction_factor"),' the same way as in the previous example (when "flaml" is used as the scheduler). We perform the evaluation in a customized schedule.')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Use ray backend or not? You can choose to use ray backend or not by specifying ",(0,r.kt)("inlineCode",{parentName:"p"},"use_ray=True")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"use_ray=False"),". When ray backend is not used, i.e., ",(0,r.kt)("inlineCode",{parentName:"p"},"use_ray=False"),", you also need to stop the evaluation function by explicitly catching the ",(0,r.kt)("inlineCode",{parentName:"p"},"StopIteration")," exception, as shown in the end of the evaluation function ",(0,r.kt)("inlineCode",{parentName:"p"},"obj_w_intermediate_report()")," in the following code example."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def obj_w_intermediate_report(resource_attr, X_train, X_test, y_train, y_test, min_resource, max_resource, config):\n    from lightgbm import LGBMClassifier\n    from sklearn.metrics import accuracy_score\n\n    # a customized schedule to perform the evaluation\n    eval_schedule = [res for res in range(min_resource, max_resource, 5000)] + [max_resource]\n    for resource in eval_schedule:\n        sampled_X_train = X_train.iloc[:resource]\n        sampled_y_train = y_train[:resource]\n\n        # construct a LGBM model from the config\n        model = LGBMClassifier(**config)\n\n        model.fit(sampled_X_train, sampled_y_train)\n        y_test_predict = model.predict(X_test)\n        test_loss = 1.0 - accuracy_score(y_test, y_test_predict)\n        # need to report the resource attribute used and the corresponding intermediate results\n        try:\n            tune.report(sample_size=resource, loss=test_loss)\n        except (StopIteration, SystemExit):\n            # do cleanup operation here\n            return\n\nresource_attr = "sample_size"\nmin_resource = 1000\nmax_resource = len(y_train)\nanalysis = tune.run(\n    partial(obj_w_intermediate_report, resource_attr, X_train, X_test, y_train, y_test, min_resource, max_resource),\n    config={\n        "n_estimators": tune.lograndint(lower=4, upper=32768),\n        "learning_rate": tune.loguniform(lower=1 / 1024, upper=1.0),\n    },\n    metric="loss",\n    mode="min",\n    resource_attr=resource_attr,\n    scheduler="asha",\n    max_resource=max_resource,\n    min_resource=min_resource,\n    reduction_factor=2,\n    time_budget_s=10,\n    num_samples = -1,\n)\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If you would like to do some cleanup opearation when the trial is stopped\nby the scheduler, you can do it when you catch the ",(0,r.kt)("inlineCode",{parentName:"li"},"StopIteration")," (when not using ray) or ",(0,r.kt)("inlineCode",{parentName:"li"},"SystemExit")," (when using ray) exception explicitly.")),(0,r.kt)("h3",{id:"warm-start"},"Warm start"),(0,r.kt)("p",null,"Related arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"points_to_evaluate"),": A list of initial hyperparameter configurations to run first."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"evaluated_rewards"),": If you have previously evaluated the parameters passed in as ",(0,r.kt)("inlineCode",{parentName:"li"},"points_to_evaluate")," , you can avoid re-running those trials by passing in the reward attributes as a list so the optimizer can be told the results without needing to re-compute the trial. Must be the same length or shorter length than ",(0,r.kt)("inlineCode",{parentName:"li"},"points_to_evaluate"),".")),(0,r.kt)("p",null,"If you are aware of some good hyperparameter configurations, you are encouraged to provide them via ",(0,r.kt)("inlineCode",{parentName:"p"},"points_to_evaluate"),". The search algorithm will try them first and use them to bootstrap the search."),(0,r.kt)("p",null,"You can use previously evaluated configurations to warm-start your tuning.\nFor example, the following code means that you know the reward for the two configs in\npoints_to_evaluate are 3.99 and 1.99, respectively, and want to\ninform ",(0,r.kt)("inlineCode",{parentName:"p"},"tune.run()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def simple_obj(config):\n    return config["a"] + config["b"]\n\nfrom flaml import tune\nconfig_search_space = {\n    "a": tune.uniform(lower=0, upper=0.99),\n    "b": tune.uniform(lower=0, upper=3)\n}\n\npoints_to_evaluate = [\n    {"b": .99, "a": 3},\n    {"b": .99, "a": 2},\n    {"b": .80, "a": 3},\n    {"b": .80, "a": 2},\n]\nevaluated_rewards = [3.99, 2.99]\n\nanalysis = tune.run(\n    simple_obj,\n    config=config_search_space,\n    mode="max",\n    points_to_evaluate=points_to_evaluate,\n    evaluated_rewards=evaluated_rewards,\n    time_budget_s=10,\n    num_samples=-1,\n)\n')),(0,r.kt)("h3",{id:"reproducibility"},"Reproducibility"),(0,r.kt)("p",null,"By default, there is randomness in our tuning process (for versions <= 0.9.1). If reproducibility is desired, you could manually set a random seed before calling ",(0,r.kt)("inlineCode",{parentName:"p"},"tune.run()"),". For example, in the following code, we call ",(0,r.kt)("inlineCode",{parentName:"p"},"np.random.seed(100)")," to set the random seed.\nWith this random seed, running the following code multiple times will generate exactly the same search trajectory. The reproducibility can only be guaranteed in sequential tuning."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import numpy as np\nnp.random.seed(100)  # This line is not needed starting from version v0.9.2.\nanalysis = tune.run(\n    simple_obj,\n    config=config_search_space,\n    mode="max",\n    num_samples=10,\n)\n')),(0,r.kt)("h2",{id:"hyperparameter-optimization-algorithm"},"Hyperparameter Optimization Algorithm"),(0,r.kt)("p",null,"To tune the hyperparameters toward your objective, you will want to use a hyperparameter optimization algorithm which can help suggest hyperparameters with better performance (regarding your objective). ",(0,r.kt)("inlineCode",{parentName:"p"},"flaml")," offers two HPO methods: CFO and BlendSearch. ",(0,r.kt)("inlineCode",{parentName:"p"},"flaml.tune")," uses BlendSearch by default when the option ","[blendsearch]"," is installed."),(0,r.kt)("h3",{id:"cfo-frugal-optimization-for-cost-related-hyperparameters"},"CFO: Frugal Optimization for Cost-related Hyperparameters"),(0,r.kt)("p",null,"CFO uses the randomized direct search method FLOW",(0,r.kt)("sup",null,"2")," with adaptive stepsize and random restart.\nIt requires a low-cost initial point as input if such point exists.\nThe search begins with the low-cost initial point and gradually move to\nhigh cost region if needed. The local search method has a provable convergence\nrate and bounded cost."),(0,r.kt)("p",null,"About FLOW",(0,r.kt)("sup",null,"2"),": FLOW",(0,r.kt)("sup",null,"2")," is a simple yet effective randomized direct search method.\nIt is an iterative optimization method that can optimize for black-box functions.\nFLOW",(0,r.kt)("sup",null,"2")," only requires pairwise comparisons between function values to perform iterative update. Comparing to existing HPO methods, FLOW",(0,r.kt)("sup",null,"2")," has the following appealing properties:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"It is applicable to general black-box functions with a good convergence rate in terms of loss."),(0,r.kt)("li",{parentName:"ol"},"It provides theoretical guarantees on the total evaluation cost incurred.")),(0,r.kt)("p",null,"The GIFs attached below demonstrate an example search trajectory of FLOW",(0,r.kt)("sup",null,"2")," shown in the loss and evaluation cost (i.e., the training time ) space respectively. FLOW",(0,r.kt)("sup",null,"2")," is used in tuning the # of leaves and the # of trees for XGBoost. The two background heatmaps show the loss and cost distribution of all configurations. The black dots are the points evaluated in FLOW",(0,r.kt)("sup",null,"2"),". Black dots connected by lines are points that yield better loss performance when evaluated."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},(0,r.kt)("img",{alt:"gif",src:n(695).Z})),(0,r.kt)("th",{parentName:"tr",align:"center"},(0,r.kt)("img",{alt:"gif",src:n(5914).Z}))))),(0,r.kt)("p",null,"From the demonstration, we can see that (1) FLOW",(0,r.kt)("sup",null,"2")," can quickly move toward the low-loss region, showing good convergence property and (2) FLOW",(0,r.kt)("sup",null,"2")," tends to avoid exploring the high-cost region until necessary."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"from flaml import CFO\ntune.run(...\n    search_alg=CFO(low_cost_partial_config=low_cost_partial_config),\n)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Recommended scenario"),": There exist cost-related hyperparameters and a low-cost\ninitial point is known before optimization.\nIf the search space is complex and CFO gets trapped into local optima, consider\nusing BlendSearch."),(0,r.kt)("h3",{id:"blendsearch-economical-hyperparameter-optimization-with-blended-search-strategy"},"BlendSearch: Economical Hyperparameter Optimization With Blended Search Strategy"),(0,r.kt)("p",null,"BlendSearch combines local search with global search. It leverages the frugality\nof CFO and the space exploration ability of global search methods such as\nBayesian optimization. Like CFO, BlendSearch requires a low-cost initial point\nas input if such point exists, and starts the search from there. Different from\nCFO, BlendSearch will not wait for the local search to fully converge before\ntrying new start points. The new start points are suggested by the global search\nmethod and filtered based on their distance to the existing points in the\ncost-related dimensions. BlendSearch still gradually increases the trial cost.\nIt prioritizes among the global search thread and multiple local search threads\nbased on optimism in face of uncertainty."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# require: pip install flaml[blendsearch]\nfrom flaml import BlendSearch\ntune.run(...\n    search_alg=BlendSearch(low_cost_partial_config=low_cost_partial_config),\n)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Recommended scenario"),": Cost-related hyperparameters exist, a low-cost\ninitial point is known, and the search space is complex such that local search\nis prone to be stuck at local optima."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Suggestion about using larger search space in BlendSearch"),".\nIn hyperparameter optimization, a larger search space is desirable because it is more likely to include the optimal configuration (or one of the optimal configurations) in hindsight. However the performance (especially anytime performance) of most existing HPO methods is undesirable if the cost of the configurations in the search space has a large variation. Thus hand-crafted small search spaces (with relatively homogeneous cost) are often used in practice for these methods, which is subject to idiosyncrasy. BlendSearch combines the benefits of local search and global search, which enables a smart (economical) way of deciding where to explore in the search space even though it is larger than necessary. This allows users to specify a larger search space in BlendSearch, which is often easier and a better practice than narrowing down the search space by hand."),(0,r.kt)("p",null,"For more technical details, please check our papers."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://arxiv.org/abs/2005.01571"},"Frugal Optimization for Cost-related Hyperparameters"),". Qingyun Wu, Chi Wang, Silu Huang. AAAI 2021.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bibtex"},"@inproceedings{wu2021cfo,\n    title={Frugal Optimization for Cost-related Hyperparameters},\n    author={Qingyun Wu and Chi Wang and Silu Huang},\n    year={2021},\n    booktitle={AAAI'21},\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.microsoft.com/en-us/research/publication/economical-hyperparameter-optimization-with-blended-search-strategy/"},"Economical Hyperparameter Optimization With Blended Search Strategy"),". Chi Wang, Qingyun Wu, Silu Huang, Amin Saied. ICLR 2021.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bibtex"},"@inproceedings{wang2021blendsearch,\n    title={Economical Hyperparameter Optimization With Blended Search Strategy},\n    author={Chi Wang and Qingyun Wu and Silu Huang and Amin Saied},\n    year={2021},\n    booktitle={ICLR'21},\n}\n")))}c.isMDXComponent=!0},5914:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/heatmap_cost_cfo_12s-f299c2309b5b414ee2ca83f1050e186c.gif"},695:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/heatmap_loss_cfo_12s-1e20ac4623c024546d2f3b5d355077de.gif"}}]);